<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Puzzle · 3D</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;1,300;1,400&family=Jost:wght@300;400;500&display=swap');
:root{--bg:#f5f3ef;--surface:#ffffff;--border:#e2ddd8;--text:#1a1814;--muted:#9a9690;--accent:#c8a96e;--snap:#3d8c6f;--sel:#5b7db8;--danger:#b85b5b}
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;overflow:hidden;background:var(--bg);color:var(--text);font-family:'Jost',sans-serif;font-weight:300;-webkit-tap-highlight-color:transparent;overscroll-behavior:none}
#bar{height:52px;background:var(--surface);border-bottom:1px solid var(--border);display:flex;align-items:center;padding:0 24px;gap:24px;flex-shrink:0}
.logo{font-family:'Cormorant Garamond',serif;font-size:17px;font-weight:400;letter-spacing:.05em}.logo em{font-style:italic;color:#2d6e4e}
.sep{width:1px;height:16px;background:var(--border)}
#barLevel{font-size:12px;color:var(--muted);font-weight:300;letter-spacing:.04em}
.bstat{font-size:11px;color:var(--muted);letter-spacing:.04em}.bstat b{color:var(--text);font-weight:400}
.spacer{flex:1}
#upBtn{display:flex;align-items:center;gap:7px;background:transparent;border:1px solid var(--border);color:var(--muted);font-family:'Jost',sans-serif;font-size:11px;letter-spacing:.06em;padding:7px 16px;border-radius:2px;cursor:pointer;transition:border-color .2s,color .2s;user-select:none;-webkit-user-select:none}
#upBtn:hover{border-color:var(--accent);color:var(--accent)}
#wrap{display:flex;height:calc(100vh - 52px)}
#cv{flex:1;position:relative;overflow:hidden;background:#d4cfc8;cursor:default}
canvas{width:100%;height:100%;display:block}
#sFlash{position:absolute;inset:0;pointer-events:none;opacity:0;background:var(--snap);mix-blend-mode:multiply}
#sFlash.go{animation:sf .5s ease-out forwards}
@keyframes sf{0%{opacity:.22}100%{opacity:0}}
#sLabel{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) scale(.95);font-family:'Cormorant Garamond',serif;font-size:15px;letter-spacing:.22em;font-style:italic;color:var(--snap);opacity:0;pointer-events:none}
#sLabel.go{animation:sl .75s ease-out forwards}
@keyframes sl{0%{opacity:1;transform:translate(-50%,-50%) scale(1)}55%{opacity:1;transform:translate(-50%,-62%) scale(1.03)}100%{opacity:0;transform:translate(-50%,-75%) scale(.95)}}
#empty{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;pointer-events:none}
#empty .ei{font-family:'Cormorant Garamond',serif;font-size:36px;opacity:.12;margin-bottom:12px}
#empty p{font-size:11px;color:var(--muted);letter-spacing:.1em;text-transform:uppercase}
#empty small{font-size:10px;color:var(--muted);display:block;margin-top:6px;opacity:.7}
#loading{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:11px;color:var(--muted);letter-spacing:.08em;text-transform:uppercase;display:none;align-items:center;gap:8px}
.spin{width:12px;height:12px;border:1.5px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin .7s linear infinite;flex-shrink:0}
@keyframes spin{to{transform:rotate(360deg)}}
#drop{position:absolute;inset:0;border:1.5px dashed var(--accent);background:rgba(200,169,110,.04);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:10px;opacity:0;pointer-events:none;transition:opacity .15s;z-index:20}
#drop.show{opacity:1;pointer-events:all}
#drop p{font-size:11px;color:var(--accent);letter-spacing:.1em;text-transform:uppercase}
#dots{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:6px}
.dot{width:7px;height:7px;border-radius:50%;background:var(--border);border:1px solid var(--muted);transition:all .3s}
.dot.placed{background:var(--snap);border-color:var(--snap);box-shadow:0 0 5px rgba(61,140,111,.4)}
.dot.sel{background:var(--sel);border-color:var(--sel)}
#panel{width:220px;flex-shrink:0;background:var(--surface);border-left:1px solid var(--border);display:flex;flex-direction:column;padding:20px 16px;gap:22px;overflow-y:auto}
.plabel{font-size:9px;letter-spacing:.15em;text-transform:uppercase;color:var(--muted);padding-bottom:9px;border-bottom:1px solid var(--border);margin-bottom:2px}
.psec{display:flex;flex-direction:column;gap:8px}
.lv{display:flex;align-items:center;gap:8px;padding:8px 10px;border-radius:3px;cursor:pointer;border:1px solid transparent;transition:border-color .15s,background .15s}
.lv:hover{background:#faf9f7}.lv.active{border-color:var(--accent);background:#faf9f7}
.lv .ln{font-size:12px;font-weight:400;flex:1;line-height:1.35}.lv .ld{font-size:10px;color:var(--muted)}
.lv .lck{font-size:11px;color:var(--snap);opacity:0}.lv.done .lck{opacity:1}
.stepper{display:flex;align-items:center;gap:6px}
.stepper button{width:22px;height:22px;border-radius:2px;background:transparent;border:1px solid var(--border);color:var(--text);font-size:14px;cursor:pointer;line-height:1;transition:border-color .15s}
.stepper button:hover{border-color:var(--accent);color:var(--accent)}
.stepper .sv{font-size:12px;width:20px;text-align:center}
.btn{width:100%;padding:9px 12px;background:transparent;border:1px solid var(--border);color:var(--text);font-family:'Jost',sans-serif;font-size:11px;letter-spacing:.06em;text-transform:uppercase;border-radius:2px;cursor:pointer;transition:border-color .15s,color .15s,background .15s}
.btn:hover{border-color:var(--accent);color:var(--accent)}
.btn.red{border-color:#ddd;color:var(--danger)}.btn.red:hover{background:var(--danger);color:#fff;border-color:var(--danger)}
.hr{display:flex;gap:8px;align-items:flex-start;font-size:11px;color:var(--muted)}
.hk{font-size:9px;background:var(--bg);border:1px solid var(--border);border-radius:2px;padding:1px 5px;color:var(--text);flex-shrink:0;white-space:nowrap;letter-spacing:.04em}
.mbg{position:fixed;inset:0;background:rgba(245,243,239,.85);backdrop-filter:blur(6px);display:none;align-items:center;justify-content:center;z-index:100}
.mbg.show{display:flex}
.modal{background:var(--surface);border:1px solid var(--border);border-radius:4px;padding:36px;max-width:360px;width:90%;display:flex;flex-direction:column;gap:18px;box-shadow:0 1px 3px rgba(0,0,0,.06),0 4px 16px rgba(0,0,0,.05)}
.modal h2{font-family:'Cormorant Garamond',serif;font-size:22px;font-weight:400;letter-spacing:.02em}
.modal p{font-size:13px;color:var(--muted);line-height:1.7}
.mstats{display:flex;gap:16px;border:1px solid var(--border);border-radius:3px;padding:16px}
.mst{flex:1;text-align:center}
.mst .v{font-family:'Cormorant Garamond',serif;font-size:26px;font-weight:300;color:var(--snap);display:block;margin-bottom:2px}
.mst .l{font-size:9px;color:var(--muted);text-transform:uppercase;letter-spacing:.12em}
.mbtns{display:flex;gap:8px;flex-wrap:wrap}.mbtns .btn{flex:1;min-width:100px}
/* Stars */
.stars{display:flex;justify-content:center;gap:10px;padding:8px 0}
.star{font-size:36px;transition:transform .3s,opacity .3s;opacity:.15;transform:scale(.7)}
.star.on{opacity:1;transform:scale(1);animation:starPop .35s ease forwards}
@keyframes starPop{0%{transform:scale(.5)}60%{transform:scale(1.25)}100%{transform:scale(1)}}
/* Email capture modal */
#emailModal{position:fixed;inset:0;background:rgba(245,243,239,.92);backdrop-filter:blur(8px);display:none;align-items:center;justify-content:center;z-index:200;padding:16px}
#emailModal.show{display:flex}
.ecard{background:var(--surface);border:1px solid var(--border);border-radius:6px;padding:40px 36px;max-width:400px;width:100%;box-shadow:0 2px 24px rgba(26,24,20,.08);animation:slideUp .45s cubic-bezier(.22,1,.36,1) forwards}
@keyframes slideUp{from{opacity:0;transform:translateY(24px)}to{opacity:1;transform:translateY(0)}}
.ecard h3{font-family:'Cormorant Garamond',serif;font-size:24px;font-weight:400;letter-spacing:.02em;margin-bottom:8px}
.ecard p{font-size:12px;color:var(--muted);line-height:1.75;margin-bottom:22px}
.einput{display:flex;gap:0;border:1px solid var(--border);border-radius:3px;overflow:hidden;transition:border-color .2s}
.einput:focus-within{border-color:var(--accent)}
.einput input{flex:1;border:none;padding:11px 14px;font-family:'Jost',sans-serif;font-size:13px;background:var(--bg);outline:none;color:var(--text)}
.einput input::placeholder{color:var(--muted)}
.einput button{background:var(--text);color:var(--surface);border:none;padding:11px 18px;font-family:'Jost',sans-serif;font-size:10px;letter-spacing:.12em;text-transform:uppercase;cursor:pointer;transition:background .2s;white-space:nowrap}
.einput button:hover{background:var(--accent)}
.einput button:disabled{opacity:.6;cursor:default}
.eskip{background:none;border:none;font-family:'Jost',sans-serif;font-size:10px;color:var(--muted);letter-spacing:.08em;cursor:pointer;margin-top:14px;display:block;width:100%;text-align:center;padding:4px;transition:color .2s}
.eskip:hover{color:var(--text)}
.ethanks{display:none;text-align:center;padding:12px 0}
.ethanks .ei{font-size:28px;margin-bottom:10px}
.ethanks p{font-size:12px;color:var(--muted);line-height:1.7}

/* Toast */
#toast{position:absolute;top:16px;left:50%;transform:translateX(-50%);background:var(--surface);border:1px solid var(--border);border-radius:4px;padding:10px 36px 10px 16px;font-size:12px;color:var(--text);letter-spacing:.03em;box-shadow:0 2px 12px rgba(0,0,0,.08);opacity:0;pointer-events:none;transition:opacity .35s,transform .35s;z-index:30;white-space:nowrap}
#toast.show{opacity:1;pointer-events:auto;animation:toastIn .4s ease forwards}
@keyframes toastIn{from{opacity:0;transform:translateX(-50%) translateY(-10px)}to{opacity:1;transform:translateX(-50%) translateY(0)}}
#toast.hide{animation:toastOut .3s ease forwards}
@keyframes toastOut{from{opacity:1;transform:translateX(-50%) translateY(0)}to{opacity:0;transform:translateX(-50%) translateY(-10px)}}
#toast .tx{position:absolute;right:10px;top:50%;transform:translateY(-50%);background:none;border:none;color:var(--muted);font-size:14px;cursor:pointer;padding:2px 4px;line-height:1}
#toast .tx:hover{color:var(--text)}

/* Touch */
canvas{touch-action:none}

/* Mobile */
@media(max-width:640px){
  #bar{padding:0 10px;gap:6px;height:44px}
  .logo{font-size:14px}
  .sep{display:none}
  #barLevel{font-size:10px;max-width:80px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .bstat{font-size:9px}
  .bstat:last-child{display:none}
  #wrap{flex-direction:column}
  #panel{width:100%;height:auto;flex-direction:row;flex-wrap:nowrap;padding:8px 10px;gap:8px;border-left:none;border-top:1px solid var(--border);overflow-x:auto;overflow-y:visible;flex-shrink:0;-webkit-overflow-scrolling:touch;align-items:flex-start}
  #panel .psec{min-width:auto;flex-shrink:0}
  #panel .psec:last-child{display:none}
  .plabel{padding-bottom:4px;margin-bottom:0;font-size:8px}
  .lv{padding:6px 8px}
  .lv .ln{font-size:11px}
  #cv{flex:1;min-height:0}
  .btn{padding:12px 14px;font-size:12px;min-height:44px;display:flex;align-items:center;justify-content:center}
  #dots{bottom:14px}
  .dot{width:9px;height:9px}
  .modal{padding:20px;gap:12px;max-width:92vw}
  .modal h2{font-size:19px}
  .mstats{padding:10px;gap:10px}
  .mst .v{font-size:20px}
  .star{font-size:28px}
  .mbtns{gap:6px}
  .mbtns .btn{min-width:0;padding:12px 8px}
  .ecard{padding:28px 20px}
  .ecard h3{font-size:20px}
  .einput input{padding:12px;font-size:14px}
  .einput button{padding:12px 14px;font-size:11px}
  .eskip{font-size:11px;padding:8px}
  #toast{font-size:11px;padding:8px 32px 8px 12px;max-width:90vw;white-space:normal;text-align:center}
}
@media(max-width:380px){
  #bar{height:40px}
  .logo{font-size:13px}
  .bstat{display:none}
  #panel{padding:6px 8px}
}
</style>
</head>
<body>
<div id="bar">
  <div class="logo">Build Your <em>Paris</em></div>
  <div class="sep"></div>
  <div id="barLevel">Loading…</div>
  <div class="spacer"></div>
  <div class="bstat">Pieces&nbsp;<b id="bPieces">0 / 0</b></div>
  <div class="bstat">Time&nbsp;<b id="bTime">0:00</b></div>
  <div class="bstat">Placements&nbsp;<b id="bMoves">0</b></div>
</div>
<div id="wrap">
  <div id="cv">
    <canvas id="c"></canvas>
    <div id="sFlash"></div>
    <div id="sLabel">snapped</div>

    <div id="empty">
      <div class="ei">◇</div>
      <p>Loading…</p>
    </div>
    <div id="loading"><div class="spin"></div>Building puzzle…</div>
    <div id="dots"></div>
    <div id="toast">Drag the pieces to the center to assemble<button class="tx" onclick="dismissToast()">&times;</button></div>
  </div>
  <div id="panel">
    <div class="psec">
      <div class="plabel">Models</div>
      <div id="lvList"><div style="font-size:11px;color:var(--muted);padding:4px 0">No models yet</div></div>
    </div>
    <div class="psec" id="pcSec" style="display:none">
      <div class="plabel">Pieces</div>
      <div style="font-size:13px;font-weight:400;color:var(--text)" id="pcVal">—</div>
    </div>
    <div class="psec">
      <div class="plabel">Actions</div>
      <button class="btn" onclick="G.reset()">Reset</button>

    </div>
    <div class="psec">
      <div class="plabel">Controls</div>
      <div class="hr"><span class="hk">Drag piece</span>Move</div>
      <div class="hr"><span class="hk">Right drag</span>Orbit</div>
      <div class="hr"><span class="hk">Scroll</span>Zoom</div>
    </div>
  </div>
</div>
<div class="mbg" id="winModal">
  <div class="modal">
    <h2>Complete.</h2>
    <div class="stars">
      <span class="star" id="star1">★</span>
      <span class="star" id="star2">★</span>
      <span class="star" id="star3">★</span>
    </div>
    <div class="mstats">
      <div class="mst"><span class="v" id="wTime">—</span><span class="l">Time</span></div>
      <div class="mst"><span class="v" id="wMoves">—</span><span class="l">Placements</span></div>
      <div class="mst"><span class="v" id="wStarLabel">—</span><span class="l">Rating</span></div>
    </div>
    <div id="winUnlock" style="display:none;padding:14px 0 2px;border-top:1px solid var(--border);margin-top:4px">
      <div style="font-size:10px;color:var(--muted);letter-spacing:.08em;text-transform:uppercase;margin-bottom:10px">Unlocked</div>
      <div style="display:flex;align-items:center;gap:10px;padding:10px 14px;background:#f5f3ef;border-radius:4px;border:1px solid var(--border)">
        <div style="font-size:18px">⬡</div>
        <div style="flex:1"><div style="font-size:13px;font-weight:400" id="winModelName">—</div><div style="font-size:10px;color:var(--muted)">Available in the builder</div></div>
      </div>
    </div>
    <div class="mbtns">
      <button class="btn" onclick="G.closeWin();G.reset()" style="border-color:var(--snap);color:var(--snap)">↺ Retry</button>
      <button class="btn" id="nextBtn" onclick="G.nextLevel()" style="background:var(--accent);border-color:var(--accent);color:#fff">Next Level →</button>
    </div>
    <div class="mbtns" style="margin-top:-10px">
      <button class="btn" id="buildBtn" style="border-color:var(--accent);color:var(--accent);display:none" onclick="window.location.href='build.html'">Build in 3D →</button>
    </div>
  </div>
</div>

<!-- ── EMAIL CAPTURE ── -->
<div id="emailModal">
  <div class="ecard">
    <!-- Default state: email form -->
    <div id="emailForm">
      <div style="font-size:22px;margin-bottom:16px;opacity:.7">◇</div>
      <h3>Stay in the loop</h3>
      <p>
        We're building more puzzles, new models, and features for creators.<br>
        Leave your email and we'll let you know when something new drops — no spam, ever.
      </p>
      <div class="einput">
        <input type="email" id="emailInput" placeholder="your@email.com" autocomplete="email">
        <button id="emailSubmit" onclick="submitEmail()">Notify me</button>
      </div>
      <p id="emailErr" style="font-size:10px;color:var(--danger);margin-top:8px;display:none">Please enter a valid email.</p>
      <button class="eskip" onclick="closeEmailModal()">No thanks, maybe later</button>
    </div>
    <!-- Success state -->
    <div class="ethanks" id="emailThanks">
      <div class="ei">✦</div>
      <p style="font-size:15px;font-family:'Cormorant Garamond',serif;font-weight:400;margin-bottom:8px">You're on the list.</p>
      <p>We'll only reach out when there's something worth sharing.<br>Thank you for playing.</p>
      <button class="eskip" onclick="closeEmailModal()" style="margin-top:18px">Back to puzzles</button>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ── GLTFLoader (inline, r128 compatible) ──────────────────────
// Minimal GLB loader — handles binary glTF (.glb) with embedded textures
function loadGLB(arrayBuffer){
  const view=new DataView(arrayBuffer);
  if(view.getUint32(0,true)!==0x46546C67) throw new Error('Not a GLB file');
  // version=view.getUint32(4,true), length=view.getUint32(8,true)
  let offset=12;
  let jsonChunk=null,binChunk=null;
  while(offset<arrayBuffer.byteLength){
    const chunkLen=view.getUint32(offset,true);
    const chunkType=view.getUint32(offset+4,true);
    offset+=8;
    if(chunkType===0x4E4F534A) jsonChunk=new TextDecoder().decode(new Uint8Array(arrayBuffer,offset,chunkLen));
    else if(chunkType===0x004E4942) binChunk=arrayBuffer.slice(offset,offset+chunkLen);
    offset+=chunkLen;
  }
  if(!jsonChunk) throw new Error('No JSON chunk in GLB');
  const gltf=JSON.parse(jsonChunk);
  return extractGLTFMeshes(gltf,binChunk);
}

function getAccessorData(gltf,binChunk,accessorIdx){
  const acc=gltf.accessors[accessorIdx];
  const bv=gltf.bufferViews[acc.bufferView];
  const byteOffset=(bv.byteOffset||0)+(acc.byteOffset||0);
  const compCount={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT4:16}[acc.type]||1;
  const TypedArr={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array}[acc.componentType];
  return new TypedArr(binChunk,byteOffset,acc.count*compCount);
}

function extractGLTFMeshes(gltf,binChunk){
  const results=[];

  // ── Images / textures — store raw bytes, avoid blob URL fetch issues ──
  const imageBytes=[];  // array of {bytes:Uint8Array, mime:string} or null
  if(gltf.images){
    for(const img of gltf.images){
      if(img.bufferView!==undefined){
        const bv=gltf.bufferViews[img.bufferView];
        // Copy bytes out so they're not tied to the ArrayBuffer view
        const src=new Uint8Array(binChunk,bv.byteOffset||0,bv.byteLength);
        const copy=new Uint8Array(src.length);
        copy.set(src);
        imageBytes.push({bytes:copy,mime:img.mimeType||'image/jpeg'});
      } else imageBytes.push(null);
    }
  }
  function matTexUrl(matIdx){
    if(matIdx===undefined||!gltf.materials) return null;
    const mat=gltf.materials[matIdx];
    const texIdx=mat?.pbrMetallicRoughness?.baseColorTexture?.index;
    if(texIdx===undefined) return null;
    const src=imageBytes[gltf.textures[texIdx]?.source];
    return src||null;  // returns {bytes, mime} object or null
  }

  // ── 4x4 matrix math (column-major, like glTF/WebGL) ───────
  function m4identity(){return[1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];}
  function m4mul(a,b){
    const r=new Array(16);
    for(let row=0;row<4;row++)for(let col=0;col<4;col++){
      let s=0;for(let k=0;k<4;k++)s+=a[row+k*4]*b[k+col*4];
      r[row+col*4]=s;
    }
    return r;
  }
  function trsMatrix(node){
    if(node.matrix) return [...node.matrix]; // already a column-major mat4
    let m=m4identity();
    if(node.translation){const[x,y,z]=node.translation;m[12]=x;m[13]=y;m[14]=z;}
    if(node.rotation){ // quaternion → rotation matrix
      const[qx,qy,qz,qw]=node.rotation;
      m[0]=1-2*(qy*qy+qz*qz); m[1]=2*(qx*qy+qz*qw);   m[2]=2*(qx*qz-qy*qw);
      m[4]=2*(qx*qy-qz*qw);   m[5]=1-2*(qx*qx+qz*qz); m[6]=2*(qy*qz+qx*qw);
      m[8]=2*(qx*qz+qy*qw);   m[9]=2*(qy*qz-qx*qw);   m[10]=1-2*(qx*qx+qy*qy);
    }
    if(node.scale){const[sx,sy,sz]=node.scale;
      m[0]*=sx;m[1]*=sx;m[2]*=sx;
      m[4]*=sy;m[5]*=sy;m[6]*=sy;
      m[8]*=sz;m[9]*=sz;m[10]*=sz;
    }
    return m;
  }
  function transformPoint(m,v){
    const w=m[3]*v[0]+m[7]*v[1]+m[11]*v[2]+m[15]||1;
    return[(m[0]*v[0]+m[4]*v[1]+m[8]*v[2]+m[12])/w,
           (m[1]*v[0]+m[5]*v[1]+m[9]*v[2]+m[13])/w,
           (m[2]*v[0]+m[6]*v[1]+m[10]*v[2]+m[14])/w];
  }
  function transformNormal(m,v){
    // Use upper-left 3x3 (transpose-inverse for normals, but for rigid+uniform-scale this is fine)
    const nx=m[0]*v[0]+m[4]*v[1]+m[8]*v[2];
    const ny=m[1]*v[0]+m[5]*v[1]+m[9]*v[2];
    const nz=m[2]*v[0]+m[6]*v[1]+m[10]*v[2];
    const len=Math.sqrt(nx*nx+ny*ny+nz*nz)||1;
    return[nx/len,ny/len,nz/len];
  }

  // ── Walk node tree ─────────────────────────────────────────
  if(!gltf.meshes) throw new Error('No meshes in GLTF');
  function visitNode(nodeIdx, parentMat){
    const node=gltf.nodes[nodeIdx];
    const localMat=trsMatrix(node);
    const worldMat=m4mul(parentMat,localMat);
    if(node.mesh!==undefined){
      const mesh=gltf.meshes[node.mesh];
      for(const prim of mesh.primitives){
        const rawPos=getAccessorData(gltf,binChunk,prim.attributes.POSITION);
        const rawNor=prim.attributes.NORMAL!==undefined?getAccessorData(gltf,binChunk,prim.attributes.NORMAL):null;
        const uv=prim.attributes.TEXCOORD_0!==undefined?getAccessorData(gltf,binChunk,prim.attributes.TEXCOORD_0):null;
        const idx=prim.indices!==undefined?getAccessorData(gltf,binChunk,prim.indices):null;
        // COLOR_0: per-vertex colour (RealityCapture / photogrammetry exports)
        let col=null;
        if(prim.attributes.COLOR_0!==undefined){
          const raw=getAccessorData(gltf,binChunk,prim.attributes.COLOR_0);
          const acc=gltf.accessors[prim.attributes.COLOR_0];
          col={data:raw,isUint8:(acc.componentType===5121),isVec4:(acc.type==='VEC4')};
        }
        // Apply world matrix to positions and normals
        const vCount=rawPos.length/3;
        const pos=new Float32Array(rawPos.length);
        const nor=rawNor?new Float32Array(rawNor.length):null;
        for(let i=0;i<vCount;i++){
          const tp=transformPoint(worldMat,[rawPos[i*3],rawPos[i*3+1],rawPos[i*3+2]]);
          pos[i*3]=tp[0];pos[i*3+1]=tp[1];pos[i*3+2]=tp[2];
          if(rawNor){
            const tn=transformNormal(worldMat,[rawNor[i*3],rawNor[i*3+1],rawNor[i*3+2]]);
            nor[i*3]=tn[0];nor[i*3+1]=tn[1];nor[i*3+2]=tn[2];
          }
        }
        results.push({pos,nor,uv,col,idx,texUrl:matTexUrl(prim.material)});
      }
    }
    if(node.children) node.children.forEach(ci=>visitNode(ci,worldMat));
  }

  // Start from scene root nodes
  const sceneIdx=(gltf.scene!==undefined)?gltf.scene:0;
  const scene=gltf.scenes?.[sceneIdx];
  const rootNodes=scene?.nodes||(gltf.nodes?[...gltf.nodes.keys()]:[]);
  rootNodes.forEach(ni=>visitNode(ni,m4identity()));

  // Fallback: if no nodes referenced any mesh, just load all meshes flat
  if(!results.length){
    for(const mesh of gltf.meshes){
      for(const prim of mesh.primitives){
        const pos=getAccessorData(gltf,binChunk,prim.attributes.POSITION);
        const nor=prim.attributes.NORMAL!==undefined?getAccessorData(gltf,binChunk,prim.attributes.NORMAL):null;
        const uv=prim.attributes.TEXCOORD_0!==undefined?getAccessorData(gltf,binChunk,prim.attributes.TEXCOORD_0):null;
        const idx=prim.indices!==undefined?getAccessorData(gltf,binChunk,prim.indices):null;
        results.push({pos,nor,uv,idx,texUrl:matTexUrl(prim.material)});
      }
    }
  }
  return results;
}

function gltfPrimsToFaces(prims){
  const faces=[];
  for(const prim of prims){
    const {pos,nor,uv,col,idx}=prim;
    const triCount=idx?idx.length/3:pos.length/9;
    for(let t=0;t<triCount;t++){
      const vi=[
        idx?idx[t*3]:t*3,
        idx?idx[t*3+1]:t*3+1,
        idx?idx[t*3+2]:t*3+2
      ];
      const p=vi.map(i=>[pos[i*3],pos[i*3+1],pos[i*3+2]]);
      const n=nor?vi.map(i=>[nor[i*3],nor[i*3+1],nor[i*3+2]]):[];
      const u=uv?vi.map(i=>[uv[i*2],uv[i*2+1]]):[];
      // Extract per-vertex colour for this triangle
      let vc=[];
      if(col){
        const {data,isUint8,isVec4}=col;
        const stride=isVec4?4:3;
        vc=vi.map(i=>isUint8
          ?[data[i*stride]/255,data[i*stride+1]/255,data[i*stride+2]/255]
          :[data[i*stride],data[i*stride+1],data[i*stride+2]]);
      }
      faces.push({
        pos:p,nor:n,uv:u,col:vc,
        texUrl:prim.texUrl,
        cx:(p[0][0]+p[1][0]+p[2][0])/3,
        cy:(p[0][1]+p[1][1]+p[2][1])/3,
        cz:(p[0][2]+p[1][2]+p[2][2])/3
      });
    }
  }
  return faces;
}

// ── OBJ PARSER ────────────────────────────────────────────────
function parseOBJ(text){
  const vp=[],vn=[],vt=[],faces=[];
  const lines=text.replace(/\r\n/g,'\n').replace(/\r/g,'\n').split('\n');
  for(const raw of lines){
    const l=raw.trim();
    if(!l||l[0]==='#') continue;
    const p=l.split(/\s+/);
    if(p[0]==='v'  && p.length>=4){vp.push([parseFloat(p[1]),parseFloat(p[2]),parseFloat(p[3])]);continue;}
    if(p[0]==='vn' && p.length>=4){vn.push([parseFloat(p[1]),parseFloat(p[2]),parseFloat(p[3])]);continue;}
    if(p[0]==='vt' && p.length>=3){vt.push([parseFloat(p[1]),parseFloat(p[2])]);continue;}
    if(p[0]==='f'){
      const toks=p.slice(1).filter(s=>s.length>0).map(s=>s.split('/'));
      if(toks.length<3) continue;
      for(let i=1;i<toks.length-1;i++){
        const tri=[toks[0],toks[i],toks[i+1]];
        const pos=[],nor=[],uv=[];
        let valid=true;
        for(const tk of tri){
          const r0=parseInt(tk[0],10);
          if(isNaN(r0)){valid=false;break;}
          const vi=r0>0?r0-1:vp.length+r0;
          if(vi<0||vi>=vp.length){valid=false;break;}
          pos.push(vp[vi]);
          if(tk[1]&&tk[1]!==''){const r1=parseInt(tk[1],10);if(!isNaN(r1)){const ti=r1>0?r1-1:vt.length+r1;if(ti>=0&&ti<vt.length)uv.push(vt[ti]);}}
          if(tk[2]&&tk[2]!==''){const r2=parseInt(tk[2],10);if(!isNaN(r2)){const ni=r2>0?r2-1:vn.length+r2;if(ni>=0&&ni<vn.length)nor.push(vn[ni]);}}
        }
        if(!valid||pos.length<3) continue;
        faces.push({pos,nor,uv,texUrl:null,
          cx:(pos[0][0]+pos[1][0]+pos[2][0])/3,
          cy:(pos[0][1]+pos[1][1]+pos[2][1])/3,
          cz:(pos[0][2]+pos[1][2]+pos[2][2])/3});
      }
    }
  }
  console.log('[OBJ] verts:',vp.length,' tris:',faces.length);
  return faces;
}

// ── SPATIAL SPLITTER ──────────────────────────────────────────
function splitFaces(faces,N){
  if(!faces.length) return [];
  let mnx=Infinity,mny=Infinity,mnz=Infinity,mxx=-Infinity,mxy=-Infinity,mxz=-Infinity;
  for(const f of faces){mnx=Math.min(mnx,f.cx);mny=Math.min(mny,f.cy);mnz=Math.min(mnz,f.cz);mxx=Math.max(mxx,f.cx);mxy=Math.max(mxy,f.cy);mxz=Math.max(mxz,f.cz);}
  const rx=mxx-mnx||1,ry=mxy-mny||1,rz=mxz-mnz||1;
  const base=Math.cbrt(rx*ry*rz/N);
  let gx=Math.max(1,Math.round(rx/base)),gy=Math.max(1,Math.round(ry/base)),gz=Math.max(1,Math.round(rz/base));
  while(gx*gy*gz<N){
    const opts=[[gx+1,gy,gz],[gx,gy+1,gz],[gx,gy,gz+1]];
    let best=opts[0],bd=Infinity;
    for(const o of opts){const d=Math.abs(o[0]*o[1]*o[2]-N);if(d<bd){bd=d;best=o;}}
    [gx,gy,gz]=best;
  }
  const cells=new Map();
  for(const f of faces){
    const ix=Math.min(gx-1,Math.floor(((f.cx-mnx)/rx)*gx));
    const iy=Math.min(gy-1,Math.floor(((f.cy-mny)/ry)*gy));
    const iz=Math.min(gz-1,Math.floor(((f.cz-mnz)/rz)*gz));
    const key=ix+iy*gx+iz*gx*gy;
    if(!cells.has(key))cells.set(key,[]);
    cells.get(key).push(f);
  }
  let groups=[...cells.values()].filter(g=>g.length>0);
  groups.sort((a,b)=>b.length-a.length);
  while(groups.length>N){const a=groups.pop(),b=groups.pop();groups.push([...a,...b]);groups.sort((a,b)=>b.length-a.length);}
  return groups.filter(g=>g.length>0);
}

// ── BUILD BufferGeometry with piece-shrink "cut lines" ────────
// Each face group is shrunk slightly toward its centroid
// creating visible gaps between pieces (puzzle-cut look)
const SHRINK=0.018; // gap size — tweak for more/less visible cuts

function buildGeo(fg,shrink){
  const hasCol=fg[0]&&fg[0].col&&fg[0].col.length>0;
  let pcx=0,pcy=0,pcz=0,cnt=0;
  for(const f of fg){for(const v of f.pos){pcx+=v[0];pcy+=v[1];pcz+=v[2];cnt++;}}
  pcx/=cnt;pcy/=cnt;pcz/=cnt;
  const s=shrink??SHRINK;
  const gv=[],gn=[],gu=[],gc=[];
  for(const f of fg){
    for(let k=0;k<3;k++){
      const v=f.pos[k];
      if(s>0&&!hasCol&&!(f.uv&&f.uv[k])){
        gv.push(v[0]+(pcx-v[0])*s,v[1]+(pcy-v[1])*s,v[2]+(pcz-v[2])*s);
      } else {
        gv.push(v[0],v[1],v[2]);
      }
      if(f.nor&&f.nor[k]) gn.push(f.nor[k][0],f.nor[k][1],f.nor[k][2]);
      if(f.uv&&f.uv[k])   gu.push(f.uv[k][0],f.uv[k][1]);
      if(hasCol){
        const vc=f.col&&f.col[k];
        gc.push(vc?vc[0]:0.5, vc?vc[1]:0.5, vc?vc[2]:0.5); // always push — length must match
      }
    }
  }
  const bg=new THREE.BufferGeometry();
  bg.setAttribute('position',new THREE.Float32BufferAttribute(gv,3));
  if(gn.length===gv.length) bg.setAttribute('normal',new THREE.Float32BufferAttribute(gn,3));
  else bg.computeVertexNormals();
  if(gu.length===(gv.length/3)*2) bg.setAttribute('uv',new THREE.Float32BufferAttribute(gu,2));
  if(hasCol) bg.setAttribute('color',new THREE.Float32BufferAttribute(gc,3));
  return bg;
}

function buildFullGeo(faces){
  const hasCol=faces[0]&&faces[0].col&&faces[0].col.length>0;
  const gv=[],gn=[],gu=[],gc=[];
  for(const f of faces){
    for(let k=0;k<3;k++){
      gv.push(f.pos[k][0],f.pos[k][1],f.pos[k][2]);
      if(f.nor&&f.nor[k]) gn.push(f.nor[k][0],f.nor[k][1],f.nor[k][2]);
      if(f.uv&&f.uv[k])   gu.push(f.uv[k][0],f.uv[k][1]);
      if(hasCol){
        const vc=f.col&&f.col[k];
        gc.push(vc?vc[0]:0.5, vc?vc[1]:0.5, vc?vc[2]:0.5);
      }
    }
  }
  const bg=new THREE.BufferGeometry();
  bg.setAttribute('position',new THREE.Float32BufferAttribute(gv,3));
  if(gn.length===gv.length) bg.setAttribute('normal',new THREE.Float32BufferAttribute(gn,3));
  else bg.computeVertexNormals();
  if(gu.length===(gv.length/3)*2) bg.setAttribute('uv',new THREE.Float32BufferAttribute(gu,2));
  if(hasCol) bg.setAttribute('color',new THREE.Float32BufferAttribute(gc,3));
  return bg;
}

// Piece outline palette — vivid colors for outlines, pieces are white
const OPAL=[0xe05a5a,0xe07a30,0xd4b800,0x4aaa44,0x3a9abb,0x7060cc,0xcc50aa,0x44bbaa,0xdd8844,0x5588dd,0xaa4466,0x66aa44,0x4466cc,0xcc6644,0x44cc88];

// ── MAIN GAME ─────────────────────────────────────────────────
const G=(()=>{
  const canvas=document.getElementById('c');
  const cvWrap=document.getElementById('cv');
  const scene=new THREE.Scene();
  const camera=new THREE.PerspectiveCamera(46,1,.01,500);
  camera.position.set(0,4,12);
  const renderer=new THREE.WebGLRenderer({canvas,antialias:true,alpha:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));
  renderer.shadowMap.enabled=true;
  renderer.shadowMap.type=THREE.PCFSoftShadowMap;

  function resize(){const w=cvWrap.clientWidth,h=cvWrap.clientHeight;renderer.setSize(w,h,false);camera.aspect=w/h;camera.updateProjectionMatrix();}
  resize();new ResizeObserver(resize).observe(cvWrap);

  scene.add(new THREE.AmbientLight(0xffffff,.8));
  const sun=new THREE.DirectionalLight(0xffffff,.85);
  sun.position.set(6,10,8);sun.castShadow=true;scene.add(sun);
  const fill=new THREE.DirectionalLight(0xd0e0ff,.22);fill.position.set(-6,3,-6);scene.add(fill);
  const fill2=new THREE.DirectionalLight(0xfff0e0,.12);fill2.position.set(3,-2,6);scene.add(fill2);

  // Shadow catcher — invisible, receives shadows only
  const gnd=new THREE.Mesh(new THREE.PlaneGeometry(80,80),new THREE.ShadowMaterial({opacity:.18}));
  gnd.rotation.x=-Math.PI/2;gnd.position.y=-2.5;gnd.receiveShadow=true;scene.add(gnd);

  // ── SKYBOX ──────────────────────────────────────────────────
  // Large inside-out sphere showing 360 equirectangular panorama
  const skyGeo=new THREE.SphereGeometry(200,60,40);
  skyGeo.scale(-1,1,1); // flip normals inward
  const skyMat=new THREE.MeshBasicMaterial({color:0xd8d0c8}); // fallback colour
  const skyMesh=new THREE.Mesh(skyGeo,skyMat);
  skyMesh.userData.isSky=true;
  scene.add(skyMesh);

  function setSkybox(url){
    if(!url){skyMat.map=null;skyMat.color.set(0xd8d0c8);skyMat.needsUpdate=true;return;}
    new THREE.TextureLoader().load(url,tex=>{
      tex.mapping=THREE.EquirectangularReflectionMapping;
      skyMat.map=tex;skyMat.color.set(0xffffff);skyMat.needsUpdate=true;
    });
  }

  const orb={r:16,theta:.3,phi:1.0,tx:0,ty:0,tz:0,active:false,lx:0,ly:0,
    update(){
      this.phi=Math.max(.1,Math.min(Math.PI-.1,this.phi));
      camera.position.set(
        this.tx+this.r*Math.sin(this.phi)*Math.sin(this.theta),
        this.ty+this.r*Math.cos(this.phi),
        this.tz+this.r*Math.sin(this.phi)*Math.cos(this.theta)
      );camera.lookAt(this.tx,this.ty,this.tz);
    }
  };orb.update();

  const levels=[];
  let curIdx=-1,pieces=[],ghostMesh=null;
  let moves=0,t0=null,tInt=null,isDone=false;

  let dragging=null;
  let dragArrowActive=null; // 'up'|'down' — Y gizmo drag
  let dragArrowStartY=0, dragArrowStartMY=0;
  let dragMoved=false; // true when piece actually moved — count one placement on release
  let lastSelected=null; // last piece touched — keeps gizmo visible after release
  const hPlane=new THREE.Plane(new THREE.Vector3(0,1,0),0); // horizontal plane
  const dragOffset=new THREE.Vector3();
  const rc=new THREE.Raycaster();
  const mn=new THREE.Vector2();

  // ── Y-ARROW GIZMOS ──────────────────────────────────────────
  // Two cone+cylinder arrows parented to the selected piece
  const arrowGroup=new THREE.Group();
  arrowGroup.userData.isGizmo=true;
  scene.add(arrowGroup);

  function makeArrow(color,dir){
    const g=new THREE.Group();
    const shaft=new THREE.Mesh(
      new THREE.CylinderGeometry(.04,.04,.55,8),
      new THREE.MeshBasicMaterial({color,depthTest:false})
    );
    shaft.renderOrder=10;
    const tip=new THREE.Mesh(
      new THREE.ConeGeometry(.12,.28,8),
      new THREE.MeshBasicMaterial({color,depthTest:false})
    );
    tip.renderOrder=10;
    const sy=dir>0?0.555:-.555;
    shaft.position.y=dir>0?.275:-.275;
    tip.position.y=dir>0?.69:-.69;
    if(dir<0){tip.rotation.z=Math.PI;}
    g.add(shaft);g.add(tip);
    g.userData.arrowDir=dir;
    // Invisible hit area (sized for touch)
    const hit=new THREE.Mesh(
      new THREE.CylinderGeometry(.4,.4,1.2,8),
      new THREE.MeshBasicMaterial({visible:false})
    );
    hit.userData.arrowDir=dir;
    g.add(hit);
    return g;
  }
  const arrowUp=makeArrow(0x44dd88,1);
  const arrowDn=makeArrow(0x44dd88,-1);
  arrowUp.position.y= 1.1;
  arrowDn.position.y=-1.1;
  arrowGroup.add(arrowUp);arrowGroup.add(arrowDn);
  arrowGroup.visible=false;

  function attachGizmo(piece){
    if(!piece){arrowGroup.visible=false;return;}
    arrowGroup.position.copy(piece.position);
    arrowGroup.visible=true;
  }

  function toNDC(e){
    const r=canvas.getBoundingClientRect();
    mn.x=((e.clientX-r.left)/r.width)*2-1;
    mn.y=-((e.clientY-r.top)/r.height)*2+1;
  }

  // ── OUTLINE — created once per piece, zero-cost toggle ───────
  function initOutline(piece,colorHex){
    piece.traverse(c=>{
      if(!c.isMesh||c.userData.isOutline) return;
      const mat=new THREE.MeshBasicMaterial({color:colorHex,side:THREE.BackSide,transparent:true,opacity:0,depthWrite:false});
      const out=new THREE.Mesh(c.geometry,mat);
      out.scale.setScalar(1.07);
      out.userData.isOutline=true;
      out.renderOrder=1;
      c.add(out);
    });
    piece.userData.outlineColor=colorHex;
  }
  function setOutline(piece,opacity){
    piece.traverse(c=>{if(c.userData.isOutline) c.material.opacity=opacity;});
  }

  // ── SNAP ─────────────────────────────────────────────────────
  function snapRadius(piece){
    const box=new THREE.Box3().setFromObject(piece);
    return box.getSize(new THREE.Vector3()).length()*.3;
  }
  function trySnap(piece){
    if(!piece||piece.userData.isPlaced) return false;
    if(piece.position.distanceTo(piece.userData.correctPos)>snapRadius(piece)) return false;
    piece.position.copy(piece.userData.correctPos);
    piece.userData.isPlaced=true;
    // Bright flash then settle to dim permanent outline
    setOutline(piece,1.0);
    let ft=0;
    const fi=setInterval(()=>{
      ft+=.04;
      if(ft>=1){clearInterval(fi);setOutline(piece,.2);piece.traverse(c=>{if(c.userData.isOutline)c.scale.setScalar(1.03);});}
      else setOutline(piece,Math.max(.2,1-ft));
    },16);
    const sf=document.getElementById('sFlash'),sl=document.getElementById('sLabel');
    sf.classList.remove('go');void sf.offsetWidth;sf.classList.add('go');
    sl.classList.remove('go');void sl.offsetWidth;sl.classList.add('go');
    levels[curIdx].piecesPlaced++;
    refreshStats();refreshDots();refreshLvList();
    if(levels[curIdx].piecesPlaced>=pieces.length) setTimeout(onWin,700);
    return true;
  }
  function liveProximity(piece){
    if(piece.userData.isPlaced) return;
    const dist=piece.position.distanceTo(piece.userData.correctPos);
    const r=snapRadius(piece);
    setOutline(piece, dist<r ? 0.95 : dist<r*2 ? 0.5 : 0.15);
  }

  // ── INPUT ────────────────────────────────────────────────────
  // Model: press-and-hold to move pieces (no click-to-select step).
  // Left drag on piece → XZ plane. Left drag on arrow → Y axis.
  // Left drag on empty → orbit (same as right drag).
  // After release: piece stays highlighted + arrows stay, so user can
  // immediately press an arrow WITHOUT re-clicking the piece.
  // Pressing a highlighted piece again re-grabs it directly.

  canvas.addEventListener('contextmenu',e=>e.preventDefault());

  function getPieceRoot(obj){
    let r=obj;
    while(r.parent&&!pieces.includes(r)) r=r.parent;
    return pieces.includes(r)&&!r.userData.isPlaced?r:null;
  }
  function getArrowDir(obj){
    let o=obj;
    while(o){
      if(o.userData.arrowDir!==undefined) return o.userData.arrowDir>0?'up':'down';
      o=o.parent;
    }
    return null;
  }
  function hitPieces(){
    const meshes=[];
    pieces.forEach(p=>{if(!p.userData.isPlaced)p.traverse(ch=>{if(ch.isMesh&&!ch.userData.isOutline)meshes.push(ch);});});
    return rc.intersectObjects(meshes,false);
  }
  function hitArrows(){
    if(!arrowGroup.visible) return [];
    const gm=[];arrowGroup.traverse(ch=>{if(ch.isMesh)gm.push(ch);});
    return rc.intersectObjects(gm,true);
  }
  function startPieceDrag(root,cx,cy){
    if(lastSelected&&lastSelected!==root) setOutline(lastSelected,0);
    dragging=root;lastSelected=root;
    dragMoved=false;
    hPlane.constant=-root.position.y;
    const pt=new THREE.Vector3();
    rc.ray.intersectPlane(hPlane,pt);
    dragOffset.copy(root.position).sub(pt);
    attachGizmo(root);
    canvas.style.cursor='grabbing';
  }
  function releaseDrag(){
    if(dragArrowActive){dragArrowActive=null;}
    if(dragging){
      if(dragMoved){moves++;refreshStats();dragMoved=false;}
      if(trySnap(dragging)){
        lastSelected=null;dragging=null;attachGizmo(null);
      } else {
        // Keep gizmo + dim highlight — user can grab arrow immediately
        setOutline(dragging,0.15);
        dragging=null; // not actively dragging, but gizmo stays
      }
    }
    canvas.style.cursor='default';
  }


  canvas.addEventListener('mousedown',e=>{
    if(e.button===2||e.button===1){orb.active=true;orb.lx=e.clientX;orb.ly=e.clientY;return;}
    if(e.button!==0) return;
    toNDC(e);rc.setFromCamera(mn,camera);

    // 1. Arrow gizmo?
    const ah=hitArrows();
    if(ah.length){
      const dir=getArrowDir(ah[0].object);
      if(dir&&lastSelected){
        dragArrowActive=dir;
        dragArrowStartY=lastSelected.position.y;
        dragArrowStartMY=e.clientY;
        dragging=lastSelected; // reattach dragging for move logic
        dragMoved=false;
        canvas.style.cursor='ns-resize';
        return;
      }
    }

    // 2. Piece?
    const ph=hitPieces();
    if(ph.length){
      const root=getPieceRoot(ph[0].object);
      if(root) { startPieceDrag(root,e.clientX,e.clientY); return; }
    }

    // 3. Empty — orbit + clear selection
    if(lastSelected){setOutline(lastSelected,0);lastSelected=null;attachGizmo(null);}
    orb.active=true;orb.lx=e.clientX;orb.ly=e.clientY;
  });

  window.addEventListener('mousemove',e=>{
    if(orb.active){
      orb.theta-=(e.clientX-orb.lx)*.005;
      orb.phi=Math.max(.05,Math.min(Math.PI-.05,orb.phi-(e.clientY-orb.ly)*.005));
      orb.lx=e.clientX;orb.ly=e.clientY;orb.update();return;
    }
    if(dragArrowActive&&dragging){
      const dy=(dragArrowStartMY-e.clientY)*0.018;
      dragging.position.y=Math.max(-3,Math.min(6,dragArrowStartY+dy));
      arrowGroup.position.copy(dragging.position);
      liveProximity(dragging);dragMoved=true;return;
    }
    if(!dragging) return;
    toNDC(e);rc.setFromCamera(mn,camera);
    const pt=new THREE.Vector3();
    if(rc.ray.intersectPlane(hPlane,pt)){
      const np=pt.clone().add(dragOffset);
      np.y=dragging.position.y;
      dragging.position.copy(np);
      arrowGroup.position.copy(np);
      liveProximity(dragging);dragMoved=true;
    }
  });

  window.addEventListener('mouseup',e=>{
    if(orb.active){orb.active=false;return;}
    releaseDrag();
  });

  canvas.addEventListener('wheel',e=>{
    orb.r=Math.max(1,Math.min(60,orb.r*(1+e.deltaY*.001)));
    orb.update();e.preventDefault();
  },{passive:false});

  // ── TOUCH EVENTS (mobile) ─────────────────────────────────────
  let touchOrb=null,pinchDist0=0,touchOrbSingle=null;

  function touchNDC(t){
    const r=canvas.getBoundingClientRect();
    mn.set(((t.clientX-r.left)/r.width)*2-1,-((t.clientY-r.top)/r.height)*2+1);
  }

  canvas.addEventListener('touchstart',e=>{
    e.preventDefault();
    if(e.touches.length===2){
      const a=e.touches[0],b=e.touches[1];
      touchOrb={lx:(a.clientX+b.clientX)/2,ly:(a.clientY+b.clientY)/2};
      pinchDist0=Math.hypot(b.clientX-a.clientX,b.clientY-a.clientY);
      dragging=null;dragArrowActive=null;touchOrbSingle=null;
      return;
    }
    const t=e.touches[0];
    touchNDC(t);rc.setFromCamera(mn,camera);
    // Arrow?
    const ah=hitArrows();
    if(ah.length){
      const dir=getArrowDir(ah[0].object);
      if(dir&&lastSelected){dragArrowActive=dir;dragArrowStartY=lastSelected.position.y;dragArrowStartMY=t.clientY;dragging=lastSelected;dragMoved=false;touchOrbSingle=null;return;}
    }
    // Piece?
    const ph=hitPieces();
    if(ph.length){
      const root=getPieceRoot(ph[0].object);
      if(root){touchNDC(t);rc.setFromCamera(mn,camera);startPieceDrag(root,t.clientX,t.clientY);touchOrbSingle=null;return;}
    }
    // Empty → single-finger orbit
    if(lastSelected){setOutline(lastSelected,0);lastSelected=null;attachGizmo(null);}
    touchOrbSingle={lx:t.clientX,ly:t.clientY};
  },{passive:false});

  canvas.addEventListener('touchmove',e=>{
    e.preventDefault();
    if(e.touches.length===2&&touchOrb){
      const a=e.touches[0],b=e.touches[1];
      const mx=(a.clientX+b.clientX)/2,my=(a.clientY+b.clientY)/2;
      orb.theta-=(mx-touchOrb.lx)*.005;
      orb.phi=Math.max(.1,Math.min(Math.PI-.1,orb.phi-(my-touchOrb.ly)*.005));
      touchOrb.lx=mx;touchOrb.ly=my;
      const d=Math.hypot(b.clientX-a.clientX,b.clientY-a.clientY);
      orb.r=Math.max(1,Math.min(60,orb.r*(pinchDist0/d)));
      pinchDist0=d;orb.update();return;
    }
    if(!e.touches.length) return;
    const t=e.touches[0];
    // Single-finger orbit on empty space
    if(touchOrbSingle&&!dragging&&!dragArrowActive){
      orb.theta-=(t.clientX-touchOrbSingle.lx)*.005;
      orb.phi=Math.max(.05,Math.min(Math.PI-.05,orb.phi-(t.clientY-touchOrbSingle.ly)*.005));
      touchOrbSingle.lx=t.clientX;touchOrbSingle.ly=t.clientY;
      orb.update();return;
    }
    if(dragArrowActive&&dragging){
      const dy=(dragArrowStartMY-t.clientY)*0.018;
      dragging.position.y=Math.max(-3,Math.min(6,dragArrowStartY+dy));
      arrowGroup.position.copy(dragging.position);
      liveProximity(dragging);dragMoved=true;return;
    }
    if(!dragging) return;
    touchNDC(t);rc.setFromCamera(mn,camera);
    const pt=new THREE.Vector3();
    if(rc.ray.intersectPlane(hPlane,pt)){
      const np=pt.clone().add(dragOffset);
      np.y=dragging.position.y;
      dragging.position.copy(np);
      arrowGroup.position.copy(np);
      liveProximity(dragging);dragMoved=true;
    }
  },{passive:false});

  canvas.addEventListener('touchend',e=>{
    e.preventDefault();
    touchOrb=null;touchOrbSingle=null;
    releaseDrag();
  },{passive:false});

  canvas.addEventListener('mousemove',e=>{
    if(dragging||orb.active||dragArrowActive) return;
    toNDC(e);rc.setFromCamera(mn,camera);
    // Check arrows first
    if(arrowGroup.visible){
      const gm=[];arrowGroup.traverse(c=>{if(c.isMesh)gm.push(c);});
      if(rc.intersectObjects(gm,true).length){canvas.style.cursor='ns-resize';return;}
    }
    const meshes=[];
    pieces.forEach(p=>{if(!p.userData.isPlaced)p.traverse(c=>{if(c.isMesh&&!c.userData.isOutline)meshes.push(c);});});
    canvas.style.cursor=rc.intersectObjects(meshes,false).length?'grab':'default';
  });

  // ── BUILD PUZZLE ─────────────────────────────────────────────
  function buildPuzzle(idx){
    if(idx<0||idx>=levels.length) return;
    curIdx=idx;
    const lvl=levels[idx];
    clearAll();
    document.getElementById('loading').style.display='flex';
    setTimeout(()=>{
      const faces=lvl.faces,N=lvl.numPieces;
      const tex=lvl.texUrl; // may be null for OBJ
      // Set panorama background for this level
      setSkybox(lvl.skyUrl||null);

      // Normalize: centre + uniform scale to fit 3-unit bbox
      let mnx=Infinity,mny=Infinity,mnz=Infinity,mxx=-Infinity,mxy=-Infinity,mxz=-Infinity;
      for(const f of faces){for(const v of f.pos){mnx=Math.min(mnx,v[0]);mny=Math.min(mny,v[1]);mnz=Math.min(mnz,v[2]);mxx=Math.max(mxx,v[0]);mxy=Math.max(mxy,v[1]);mxz=Math.max(mxz,v[2]);}}
      const cx=(mnx+mxx)/2,cy=(mny+mxy)/2,cz=(mnz+mxz)/2;
      const maxD=Math.max(mxx-mnx,mxy-mny,mxz-mnz)||1,scl=3/maxD;
      const nf=faces.map(f=>({
        pos:f.pos.map(v=>[(v[0]-cx)*scl,(v[1]-cy)*scl,(v[2]-cz)*scl]),
        nor:f.nor,uv:f.uv,col:f.col,texUrl:f.texUrl,
        cx:(f.cx-cx)*scl,cy:(f.cy-cy)*scl,cz:(f.cz-cz)*scl
      }));

      // Load texture once if available
      let texture=null;
      // Detect vertex colours BEFORE finishBuild — used by ghost + pieces
      const hasVertCol=nf[0]&&nf[0].col&&nf[0].col.length>0;
      function finishBuild(){
        // Ghost
        const ghostMatProps={
          color:(texture||hasVertCol)?0xffffff:0xb0a898,
          transparent:true,opacity:(texture||hasVertCol)?.13:.07,
          depthWrite:false,side:THREE.DoubleSide
        };
        if(!texture&&hasVertCol) ghostMatProps.vertexColors=true;
        const ghostMat=new THREE.MeshStandardMaterial(ghostMatProps);
        if(texture) ghostMat.map=texture;
        ghostMesh=new THREE.Mesh(buildFullGeo(nf),ghostMat);
        ghostMesh.userData.isGhost=true;
        ghostMesh.position.y=lvl.offsetY||0;
        scene.add(ghostMesh);

        // Build pieces
        const chunks=splitFaces(nf,N);
        const radius=5.5+N*.28;
        chunks.forEach((chunk,i)=>{
          const geo=buildGeo(chunk);
          const outlineColor=OPAL[i%OPAL.length];
          let mat;
          if(texture){
            mat=new THREE.MeshStandardMaterial({map:texture,roughness:.6,metalness:.05,side:THREE.DoubleSide});
          } else if(hasVertCol){
            // Vertex colour model (RealityCapture etc.)
            mat=new THREE.MeshStandardMaterial({vertexColors:true,roughness:.75,metalness:.0,side:THREE.DoubleSide});
          } else {
            mat=new THREE.MeshStandardMaterial({color:0xddd8d0,roughness:.65,metalness:.05,side:THREE.DoubleSide});
          }
          const mesh=new THREE.Mesh(geo,mat);
          mesh.castShadow=true;
          const oy=lvl.offsetY||0;
          mesh.userData={correctPos:new THREE.Vector3(0,oy,0),isPlaced:false,pieceIdx:i};
          const ang=(i/chunks.length)*Math.PI*2;
          const r2=radius+(i%2===0?0:1.8);
          mesh.position.set(Math.cos(ang)*r2,0.1,Math.sin(ang)*r2);
          initOutline(mesh,outlineColor);
          scene.add(mesh);pieces.push(mesh);
        });

        lvl.piecesPlaced=0;isDone=false;moves=0;t0=Date.now();
        clearInterval(tInt);tInt=setInterval(refreshTimer,1000);
        document.getElementById('loading').style.display='none';
        document.getElementById('empty').style.display='none';
        document.getElementById('barLevel').textContent=lvl.name;
        document.getElementById('pcSec').style.display='flex';
        document.getElementById('pcVal').textContent=N+' pieces';
        orb.r=16;orb.theta=.4;orb.phi=.95;orb.tx=0;orb.ty=0;orb.tz=0;orb.update();
        refreshAll();
        showToast();
      }

      if(tex){
        // tex is {bytes:Uint8Array, mime:string} — no fetch needed, direct decode
        const blob=new Blob([tex.bytes],{type:tex.mime});
        createImageBitmap(blob).then(bmp=>{
          const cvs=document.createElement('canvas');
          cvs.width=bmp.width; cvs.height=bmp.height;
          const ctx=cvs.getContext('2d');
          // Flip Y manually to match glTF spec (V=0 at bottom, canvas V=0 at top)
          ctx.translate(0,bmp.height);
          ctx.scale(1,-1);
          ctx.drawImage(bmp,0,0);
          texture=new THREE.CanvasTexture(cvs);
          texture.flipY=false; // already flipped in canvas
          texture.needsUpdate=true;
          finishBuild();
        }).catch(()=>{texture=null;finishBuild();});
      } else {
        finishBuild();
      }
    },30);
  }

  function clearAll(){
    dragging=null;dragArrowActive=null;lastSelected=null;
    attachGizmo(null);
    const rm=new Set();
    pieces.forEach(p=>rm.add(p));
    scene.traverse(c=>{if(c.userData.isGhost)rm.add(c);});
    rm.forEach(c=>scene.remove(c));
    pieces=[];ghostMesh=null;clearInterval(tInt);
  }

  function onWin(){
    if(isDone)return;isDone=true;clearInterval(tInt);
    const e=Math.floor((Date.now()-t0)/1000);
    document.getElementById('wTime').textContent=Math.floor(e/60)+':'+(e%60).toString().padStart(2,'0');
    document.getElementById('wMoves').textContent=moves;
    levels[curIdx].completed=true;refreshLvList();

    // ── Star rating ───────────────────────────────────────────
    // 3 stars: moves <= pieces*1.5, 2 stars: moves <= pieces*3, 1 star: rest
    const N=levels[curIdx].numPieces;
    const stars = moves<=Math.ceil(N*1.5) ? 3 : moves<=N*3 ? 2 : 1;
    const labels=['','★','★★','★★★'];
    document.getElementById('wStarLabel').textContent=labels[stars];
    // Animate stars with delay
    for(let i=1;i<=3;i++){
      const el=document.getElementById('star'+i);
      el.classList.remove('on');
      if(i<=stars) setTimeout(()=>el.classList.add('on'), i*180);
    }

    // ── Next level button ─────────────────────────────────────
    const hasNext = curIdx < levels.length-1;
    document.getElementById('nextBtn').style.opacity = hasNext ? '1' : '.4';
    document.getElementById('nextBtn').disabled = !hasNext;

    // ── Unlock model for the builder ──────────────────────────
    const lvl=levels[curIdx];
    document.getElementById('winUnlock').style.display='none';
    document.getElementById('buildBtn').style.display='none';
    if(lvl.texUrl){
      const key='puzzle_collection';
      let col=[];
      try{col=JSON.parse(localStorage.getItem(key)||'[]');}catch(ex){}
      const id=lvl.name+':'+curIdx;
      if(!col.some(m=>m.id===id)){
        col.push({id,name:lvl.name,texUrl:lvl.texUrl,unlockedAt:Date.now()});
        localStorage.setItem(key,JSON.stringify(col));
      }
      document.getElementById('winUnlock').style.display='block';
      document.getElementById('winModelName').textContent=lvl.name;
      document.getElementById('buildBtn').style.display='block';
    }
    document.getElementById('winModal').classList.add('show');
    // Show email capture once — right after completing the very first puzzle
    maybeShowEmailCapture();
  }

  // Show email capture once — only after completing the first level, never again
  function maybeShowEmailCapture(){
    if(curIdx!==0) return;
    const asked = localStorage.getItem('pf_email_asked');
    const given = localStorage.getItem('pf_email_given');
    if(!asked && !given){
      localStorage.setItem('pf_email_asked','1');
      setTimeout(()=>document.getElementById('emailModal').classList.add('show'), 380);
    }
  }

  function refreshAll(){refreshStats();refreshDots();refreshLvList();}
  function refreshStats(){
    const lvl=levels[curIdx];
    document.getElementById('bPieces').textContent=lvl?lvl.piecesPlaced+' / '+pieces.length:'0 / 0';
    document.getElementById('bMoves').textContent=moves;
  }
  function refreshTimer(){
    if(!t0)return;
    const e=Math.floor((Date.now()-t0)/1000);
    document.getElementById('bTime').textContent=Math.floor(e/60)+':'+(e%60).toString().padStart(2,'0');
  }
  function refreshDots(){
    const el=document.getElementById('dots');
    if(!pieces.length){el.innerHTML='';return;}
    el.innerHTML=pieces.map(p=>{
      let c='dot';
      if(p.userData.isPlaced)c+=' placed';
      else if(p===dragging)c+=' sel';
      return`<div class="${c}"></div>`;
    }).join('');
  }
  function refreshLvList(){
    const el=document.getElementById('lvList');
    if(!levels.length){el.innerHTML='<div style="font-size:11px;color:var(--muted);padding:4px 0">No models yet</div>';return;}
    el.innerHTML=levels.map((l,i)=>`<div class="lv ${i===curIdx?'active':''} ${l.completed?'done':''}" onclick="G.loadLvl(${i})"><div style="flex:1"><div class="ln">${l.name}</div><div class="ld">${l.numPieces} pieces</div></div><span class="lck">✓</span></div>`).join('');
  }

  // ── LOAD LEVELS FROM levels.json ────────────────────────────
  async function loadLevelsFromJSON(){
    document.getElementById('loading').style.display='flex';
    document.getElementById('empty').style.display='none';
    try{
      // Cache-bust so players always get the latest after admin publishes
      const resp=await fetch('levels.json?t='+Date.now());
      if(!resp.ok) throw new Error('levels.json not found');
      const data=await resp.json();
      if(!data||!data.length){
        document.getElementById('loading').style.display='none';
        document.getElementById('empty').style.display='block';
        return;
      }
      for(const row of data){
        try{
          let faces=[],texUrl=null;
          if(row.model_data){
            // model_data is base64-encoded GLB
            // Decode base64 safely (handle padding, whitespace)
            const _b64=row.model_data.replace(/\s/g,'');
            const bin=atob(_b64);
            const buf=new ArrayBuffer(bin.length);
            const u8=new Uint8Array(buf);
            for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
            const prims=loadGLB(buf);
            faces=gltfPrimsToFaces(prims);
            texUrl=prims.find(p=>p.texUrl)?.texUrl||null;
            // Note: col (vertex colours) flows through faces directly — no extra step needed
            // Apply admin calibration rotation to fix model orientation
            if(row.calib_rx||row.calib_ry||row.calib_rz){
              const _rx=(row.calib_rx||0)*Math.PI/180,_ry=(row.calib_ry||0)*Math.PI/180,_rz=(row.calib_rz||0)*Math.PI/180;
              const _cX=Math.cos(_rx),_sX=Math.sin(_rx),_cY=Math.cos(_ry),_sY=Math.sin(_ry),_cZ=Math.cos(_rz),_sZ=Math.sin(_rz);
              const _rotV=v=>{
                let x=v[0]*_cZ-v[1]*_sZ,y=v[0]*_sZ+v[1]*_cZ,z=v[2];
                let x2=x*_cY+z*_sY,z2=-x*_sY+z*_cY;x=x2;z=z2;
                let y2=y*_cX-z*_sX,z3=y*_sX+z*_cX;return[x,y2,z3];
              };
              faces=faces.map(f=>{
                const nc=_rotV([f.cx,f.cy,f.cz]);
                return{...f,pos:f.pos.map(v=>_rotV(v)),nor:f.nor?f.nor.map(v=>_rotV(v)):f.nor,cx:nc[0],cy:nc[1],cz:nc[2]};
              });
            }
          }
          // sky_data is base64-encoded image
          let skyUrl=null;
          if(row.sky_data){
            const sb=atob(row.sky_data);
            const sa=new Uint8Array(sb.length);
            for(let i=0;i<sb.length;i++) sa[i]=sb.charCodeAt(i);
            skyUrl=URL.createObjectURL(new Blob([sa],{type:row.sky_mime||'image/jpeg'}));
          }
          levels.push({
            name:row.name,faces,texUrl,skyUrl,
            numPieces:row.pieces||15,piecesPlaced:0,completed:false,
            offsetY:row.offset_y||0,
            modelUrl:null
          });
          refreshLvList();
        }catch(e){console.error('Level load error:',row.name,e);}
      }
      document.getElementById('loading').style.display='none';
      document.getElementById('empty').style.display='none';
      if(levels.length) buildPuzzle(0);
      else {document.getElementById('empty').style.display='block'; document.querySelector('#empty p').textContent='No levels yet';}
    }catch(e){
      document.getElementById('loading').style.display='none';
      document.getElementById('empty').style.display='block';
      document.querySelector('#empty p').textContent='Could not load levels';
      console.error('levels.json error:',e);
    }
  }
  loadLevelsFromJSON();

  (function loop(){requestAnimationFrame(loop);renderer.render(scene,camera);})();

  return{
    loadLvl(i){buildPuzzle(i);},
    reset(){if(curIdx>=0)buildPuzzle(curIdx);},
    nextLevel(){
      document.getElementById('winModal').classList.remove('show');
      if(curIdx<levels.length-1) buildPuzzle(curIdx+1);
    },

    removeLvl(){
      if(curIdx<0)return;levels.splice(curIdx,1);clearAll();
      if(levels.length>0)buildPuzzle(Math.min(curIdx,levels.length-1));
      else{curIdx=-1;document.getElementById('barLevel').textContent='No model loaded';document.getElementById('empty').style.display='block';document.getElementById('pcSec').style.display='none';refreshAll();}
    },
    closeWin(){
      document.getElementById('winModal').classList.remove('show');
    }
  };
})();
</script>

<!-- ── EMAIL CAPTURE LOGIC ─────────────────────────────────────── -->
<script>
// ── Formspree endpoint ────────────────────────────────────────────
// FREE: 50 submissions/month — formspree.io → New Form → copy your ID
// Replace YOUR_FORM_ID with e.g. "xpwzgkjb"
// Until configured, submissions are console-logged only (safe for testing)
const FORMSPREE_ID = 'mreaqbee';

async function submitEmail(){
  const input = document.getElementById('emailInput');
  const btn   = document.getElementById('emailSubmit');
  const err   = document.getElementById('emailErr');
  const email = input.value.trim();

  if(!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)){
    err.style.display = 'block'; input.focus(); return;
  }
  err.style.display = 'none';
  btn.disabled = true; btn.textContent = 'Sending…';

  try{
    if(FORMSPREE_ID === 'YOUR_FORM_ID'){
      // No endpoint yet — log only
      console.log('[Build Your Paris] Email captured (configure Formspree to save):', email);
      await new Promise(r => setTimeout(r, 700));
    } else {
      const res = await fetch('https://formspree.io/f/' + FORMSPREE_ID, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
        body: JSON.stringify({ email, source: 'post-puzzle-win', ts: new Date().toISOString() })
      });
      if(!res.ok) throw new Error('Send failed ' + res.status);
    }

    localStorage.setItem('pf_email_given','1');
    document.getElementById('emailForm').style.display   = 'none';
    document.getElementById('emailThanks').style.display = 'block';
    setTimeout(closeEmailModal, 3200);

  } catch(e) {
    btn.disabled = false; btn.textContent = 'Notify me';
    err.textContent = 'Something went wrong — try again.';
    err.style.display = 'block';
  }
}

function closeEmailModal(){
  document.getElementById('emailModal').classList.remove('show');
  setTimeout(()=>{
    document.getElementById('emailForm').style.display   = 'block';
    document.getElementById('emailThanks').style.display = 'none';
    document.getElementById('emailInput').value = '';
    document.getElementById('emailErr').style.display    = 'none';
    const btn = document.getElementById('emailSubmit');
    btn.disabled = false; btn.textContent = 'Notify me';
  }, 420);
}

document.getElementById('emailInput').addEventListener('keydown', e => {
  if(e.key === 'Enter') submitEmail();
});

// ── TOAST ────────────────────────────────────────────────────
let toastTimer=null;
function showToast(){
  const el=document.getElementById('toast');
  el.classList.remove('hide');
  el.classList.add('show');
  clearTimeout(toastTimer);
  toastTimer=setTimeout(dismissToast,4500);
}
function dismissToast(){
  clearTimeout(toastTimer);
  const el=document.getElementById('toast');
  el.classList.remove('show');
  el.classList.add('hide');
}
</script>
</body>
</html>
