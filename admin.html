<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Admin · Puzzle &amp; Form</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300&family=Jost:wght@300;400;500&display=swap');
:root{--bg:#f5f3ef;--s:#fff;--b:#e2ddd8;--t:#1a1814;--m:#9a9690;--a:#c8a96e;--green:#3d8c6f;--red:#c0392b}
*{margin:0;padding:0;box-sizing:border-box}
html,body{min-height:100%;background:var(--bg);color:var(--t);font-family:'Jost',sans-serif;font-weight:300}

/* ── LOGIN SCREEN ── */
#loginScreen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:var(--bg);z-index:999}
.loginBox{background:var(--s);border:1px solid var(--b);border-radius:6px;padding:48px;width:360px;display:flex;flex-direction:column;gap:18px;box-shadow:0 2px 20px rgba(0,0,0,.06)}
.loginBox h1{font-family:'Cormorant Garamond',serif;font-size:22px;font-weight:400}
.loginBox p{font-size:12px;color:var(--m);line-height:1.6}
.field{display:flex;flex-direction:column;gap:6px}
.field label{font-size:11px;color:var(--m)}
.field input{padding:10px 12px;border:1px solid var(--b);border-radius:3px;font-family:'Jost',sans-serif;font-size:13px;background:var(--bg);outline:none;transition:border-color .2s}
.field input:focus{border-color:var(--a)}
.loginBtn{padding:11px;background:var(--a);color:#fff;border:none;border-radius:3px;font-family:'Jost',sans-serif;font-size:12px;letter-spacing:.06em;cursor:pointer;transition:opacity .2s}
.loginBtn:hover{opacity:.88}
#loginErr{font-size:11px;color:var(--red);display:none}

/* ── APP ── */
#app{display:none}
#topbar{height:54px;background:var(--s);border-bottom:1px solid var(--b);display:flex;align-items:center;padding:0 28px;gap:16px;position:sticky;top:0;z-index:10}
.logo{font-family:'Cormorant Garamond',serif;font-size:17px;font-weight:400}.logo em{color:var(--a);font-style:italic}
.tag{font-size:9px;letter-spacing:.14em;text-transform:uppercase;color:var(--m);background:var(--bg);border:1px solid var(--b);padding:2px 8px;border-radius:2px}
.spacer{flex:1}
#statusMsg{font-size:11px;color:var(--m)}
.publishBtn{background:var(--green);color:#fff;border:none;border-radius:3px;padding:9px 22px;font-family:'Jost',sans-serif;font-size:11px;letter-spacing:.07em;cursor:pointer;transition:opacity .2s;display:flex;align-items:center;gap:8px}
.publishBtn:hover{opacity:.85}
.publishBtn:disabled{opacity:.5;cursor:not-allowed}

/* ── LAYOUT ── */
#main{display:flex;min-height:calc(100vh - 54px)}

/* ── SIDEBAR ── */
#sidebar{width:280px;flex-shrink:0;background:var(--s);border-right:1px solid var(--b);display:flex;flex-direction:column}
.shead{font-size:9px;letter-spacing:.14em;text-transform:uppercase;color:var(--m);padding:16px 20px 12px;border-bottom:1px solid var(--b)}
#lvList{flex:1;overflow-y:auto;padding:10px 12px;display:flex;flex-direction:column;gap:4px}
.lvItem{display:flex;align-items:center;gap:8px;padding:9px 10px;border-radius:4px;cursor:pointer;border:1px solid transparent;transition:all .15s;user-select:none}
.lvItem:hover{background:#faf9f7}.lvItem.active{border-color:var(--a);background:#faf9f7}
.lvNum{width:22px;height:22px;border-radius:3px;background:var(--bg);border:1px solid var(--b);display:flex;align-items:center;justify-content:center;font-size:10px;color:var(--m);flex-shrink:0}
.lvItem.active .lvNum{background:var(--a);border-color:var(--a);color:#fff}
.lvTitle{font-size:12px;font-weight:400;flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.lvMeta{font-size:10px;color:var(--m)}
.drag-handle{cursor:grab;color:var(--b);font-size:14px;line-height:1;flex-shrink:0}
.drag-handle:active{cursor:grabbing}
.lvItem.drag-over{border-color:var(--a);background:#fdf8f0}
#addBtn{margin:12px;padding:10px;border:1px dashed var(--b);border-radius:4px;background:transparent;color:var(--m);font-family:'Jost',sans-serif;font-size:11px;letter-spacing:.05em;cursor:pointer;transition:all .2s}
#addBtn:hover{border-color:var(--a);color:var(--a)}

/* ── EDITOR ── */
#editor{flex:1;padding:36px 40px;overflow-y:auto}
#noSel{display:flex;flex-direction:column;align-items:center;justify-content:center;height:300px;gap:12px;color:var(--m)}
#noSel .ni{font-size:36px;opacity:.12}
.card{background:var(--s);border:1px solid var(--b);border-radius:6px;padding:28px;margin-bottom:20px;max-width:620px}
.cardHead{font-size:9px;letter-spacing:.14em;text-transform:uppercase;color:var(--m);padding-bottom:14px;border-bottom:1px solid var(--b);margin-bottom:22px}
.row{display:flex;flex-direction:column;gap:6px;margin-bottom:18px}
.row label{font-size:11px;color:var(--m)}
.row input[type=text]{width:100%;padding:9px 12px;border:1px solid var(--b);border-radius:3px;font-family:'Jost',sans-serif;font-size:13px;background:var(--bg);outline:none;transition:border-color .2s}
.row input[type=text]:focus{border-color:var(--a)}
.sliderRow{display:flex;align-items:center;gap:12px}
.sliderRow input[type=range]{flex:1;accent-color:var(--a);cursor:pointer}
.sliderVal{font-size:14px;font-weight:400;min-width:28px}

/* Upload zones */
.uzone{border:1px dashed var(--b);border-radius:4px;padding:26px;text-align:center;cursor:pointer;transition:all .2s;position:relative}
.uzone:hover,.uzone.over{border-color:var(--a);background:rgba(200,169,110,.04)}
.uzone input[type=file]{position:absolute;inset:0;opacity:0;cursor:pointer;width:100%;height:100%}
.uzIcon{font-size:22px;opacity:.22;margin-bottom:8px}
.uzLabel{font-size:11px;color:var(--m);letter-spacing:.05em}
.uzSub{font-size:10px;color:var(--b);margin-top:4px}
.fileInfo{display:flex;align-items:center;gap:10px;padding:10px 12px;background:var(--bg);border-radius:3px;margin-top:10px}
.fileInfo .fn{font-size:12px;flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.fileInfo .fs{font-size:10px;color:var(--m)}
.fileInfo .fx{background:none;border:none;color:var(--m);cursor:pointer;font-size:13px;padding:2px 6px;border-radius:2px}
.fileInfo .fx:hover{color:var(--red)}
.skyThumb{width:100%;max-height:80px;object-fit:cover;border-radius:3px;margin-top:10px;display:none}

/* Calibration */
.calibRow{display:flex;align-items:center;gap:10px;margin-bottom:12px}
.calibRow label{font-size:11px;color:var(--m);width:90px;flex-shrink:0}
.calibRow input[type=range]{flex:1;accent-color:var(--a)}
.calibRow .cv{font-size:11px;color:var(--t);min-width:40px;text-align:right}
.preview3d{width:100%;height:260px;border-radius:4px;overflow:hidden;background:#1a1814;position:relative;margin-top:4px}
.preview3d canvas{display:block}
.previewHint{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);font-size:9px;color:rgba(255,255,255,.3);letter-spacing:.08em;pointer-events:none}

/* Cut preview */
.cutPreview{width:100%;height:300px;border-radius:4px;overflow:hidden;background:#1a1814;position:relative;margin-top:4px}
.cutPreview canvas{display:block}
.cutModes{display:flex;gap:0;border:1px solid var(--b);border-radius:3px;overflow:hidden;margin-bottom:14px}
.cutMode{flex:1;padding:8px 12px;background:var(--bg);border:none;font-family:'Jost',sans-serif;font-size:11px;letter-spacing:.04em;cursor:pointer;color:var(--m);transition:all .15s;text-align:center}
.cutMode.active{background:var(--a);color:#fff}
.cutMode:not(:last-child){border-right:1px solid var(--b)}
.cutPlaneList{display:flex;flex-direction:column;gap:4px;margin-top:10px}
.cutPlaneItem{display:flex;align-items:center;gap:8px;padding:6px 8px;background:var(--bg);border-radius:3px;font-size:11px}
.cutPlaneItem label{color:var(--m);width:40px;flex-shrink:0}
.cutPlaneItem input[type=range]{flex:1;accent-color:var(--a)}
.cutPlaneItem .cpv{font-size:10px;color:var(--t);min-width:36px;text-align:right}
.cutPlaneItem button{background:none;border:none;color:var(--m);cursor:pointer;font-size:13px;padding:0 4px}
.cutPlaneItem button:hover{color:var(--red)}

/* Danger */
.dangerBtn{background:none;border:1px solid #e8c4c4;color:var(--red);border-radius:3px;padding:8px 16px;font-family:'Jost',sans-serif;font-size:11px;letter-spacing:.05em;cursor:pointer;transition:all .2s}
.dangerBtn:hover{background:var(--red);color:#fff;border-color:var(--red)}

/* Progress overlay */
#progressOverlay{display:none;position:fixed;inset:0;background:rgba(245,243,239,.88);z-index:200;align-items:center;justify-content:center;flex-direction:column;gap:16px}
#progressOverlay.show{display:flex}
.progBox{background:var(--s);border:1px solid var(--b);border-radius:6px;padding:28px 36px;min-width:300px;text-align:center}
.progLabel{font-size:13px;margin-bottom:14px;color:var(--t)}
.progBar{height:3px;background:var(--b);border-radius:2px;overflow:hidden}
.progFill{height:100%;background:var(--green);border-radius:2px;transition:width .4s;width:0%}

/* Toast */
#toast{position:fixed;bottom:24px;left:50%;transform:translateX(-50%) translateY(12px);background:#1a1814;color:#fff;padding:10px 20px;border-radius:4px;font-size:12px;opacity:0;transition:all .3s;pointer-events:none;z-index:300}
#toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
</style>
</head>
<body>

<!-- ── LOGIN ── -->
<div id="loginScreen">
  <div class="loginBox">
    <h1>Admin <em style="color:var(--a)">·</em> Puzzle &amp; Form</h1>
    <p>Enter your GitHub Personal Access Token and admin password to manage levels.</p>
    <div class="field">
      <label>Detected repository</label>
      <div style="padding:9px 12px;border:1px solid var(--b);border-radius:3px;font-size:13px;background:#faf9f7;color:var(--m)" id="repoDisplay">detecting...</div>
    </div>
    <div class="field"><label>GitHub Personal Access Token</label><input type="password" id="inToken" placeholder="ghp_xxxxxxxxxxxx" autocomplete="new-password"></div>
    <div class="field"><label>Admin Password</label><input type="password" id="inPw" placeholder="admin" autocomplete="new-password" onkeydown="if(event.key==='Enter')login()"></div>
    <div id="loginErr" style="font-size:11px;color:var(--red);display:none">error</div>
    <button class="loginBtn" onclick="login()">Sign in</button>
    <p style="font-size:10px;color:var(--m)">Token stored in browser session only, sent only to GitHub API.</p>
  </div>
</div>

<!-- ── APP ── -->
<div id="app">
  <div id="topbar">
    <div class="logo">Puzzle <em>&amp;</em> Form <span class="tag">Admin</span></div>
    <div class="spacer"></div>
    <div id="statusMsg"></div>
    <button class="publishBtn" id="publishBtn" onclick="publish()" disabled>
      <span id="publishLabel">Publish</span>
    </button>
  </div>
  <div id="main">
    <div id="sidebar">
      <div class="shead">Levels</div>
      <div id="lvList"></div>
      <button id="addBtn" onclick="addLevel()">+ Add Level</button>
    </div>
    <div id="editor">
      <div id="noSel"><div class="ni">◇</div><p style="font-size:12px">Select a level to edit</p></div>
      <div id="lvEditor" style="display:none">

        <!-- Info -->
        <div class="card">
          <div class="cardHead">Level Info</div>
          <div class="row"><label>Level Name</label><input type="text" id="eName" oninput="syncField('name',this.value)"></div>
          <div class="row"><label>Number of Pieces</label>
            <div class="sliderRow">
              <input type="range" id="ePieces" min="3" max="40" value="15" oninput="document.getElementById('ePiecesVal').textContent=this.value;syncField('pieces',+this.value)">
              <div class="sliderVal" id="ePiecesVal">15</div>
            </div>
          </div>
          <div class="row"><label>Snap Difficulty</label>
            <div style="display:flex;align-items:center;gap:10px">
              <span style="font-size:10px;color:var(--m)">Easy</span>
              <input type="range" id="eSnap" min="10" max="60" value="30" style="flex:1;accent-color:var(--a);cursor:pointer" oninput="document.getElementById('eSnapVal').textContent=this.value+'%';syncField('snapTolerance',+this.value)">
              <span style="font-size:10px;color:var(--m)">Hard</span>
              <div class="sliderVal" id="eSnapVal" style="min-width:36px">30%</div>
            </div>
            <div style="font-size:10px;color:var(--m);margin-top:4px">How close a piece must be to snap into place (% of piece size)</div>
          </div>
        </div>

        <!-- 3D Model + Calibration -->
        <div class="card">
          <div class="cardHead">3D Model</div>
          <div class="uzone" id="modelZone">
            <input type="file" id="modelInput" accept=".glb,.obj" onchange="handleModel(this.files[0])">
            <div class="uzIcon">⬡</div>
            <div class="uzLabel">Click or drag a .glb or .obj file</div>
            <div class="uzSub">.glb recommended — preserves textures</div>
          </div>
          <div class="fileInfo" id="modelInfo" style="display:none">
            <span class="fn" id="modelFn"></span>
            <span class="fs" id="modelFs"></span>
            <button class="fx" onclick="clearModel()">✕</button>
          </div>

          <!-- 3D preview + calibration sliders — shown after model loaded -->
          <div id="calibSection" style="display:none;margin-top:18px">
            <div style="font-size:9px;letter-spacing:.14em;text-transform:uppercase;color:var(--m);margin-bottom:14px;padding-top:14px;border-top:1px solid var(--b)">Calibration</div>
            <div class="calibRow"><label>Rotate X</label><input type="range" id="cRX" min="-180" max="180" value="0" oninput="updateCalib()"><span class="cv" id="cRXv">0°</span></div>
            <div class="calibRow"><label>Rotate Y</label><input type="range" id="cRY" min="-180" max="180" value="0" oninput="updateCalib()"><span class="cv" id="cRYv">0°</span></div>
            <div class="calibRow"><label>Rotate Z</label><input type="range" id="cRZ" min="-180" max="180" value="0" oninput="updateCalib()"><span class="cv" id="cRZv">0°</span></div>
            <div class="calibRow"><label>Move up/down</label><input type="range" id="cOY" min="-3" max="3" step="0.05" value="0" oninput="updateOffsetY()"><span class="cv" id="cOYv">0</span></div>
            <div class="preview3d" id="previewContainer">
              <canvas id="previewCanvas"></canvas>
              <div class="previewHint">Drag to orbit · scroll to zoom</div>
            </div>
            <button onclick="resetCalib()" style="margin-top:10px;background:none;border:1px solid var(--b);color:var(--m);font-family:'Jost',sans-serif;font-size:10px;padding:6px 14px;border-radius:3px;cursor:pointer;letter-spacing:.05em">Reset all</button>
          </div>
        </div>

        <!-- 360° Sky -->
        <div class="card">
          <div class="cardHead">360° Panorama <span style="font-weight:300;text-transform:none;letter-spacing:0;font-size:10px;color:var(--m)">(optional)</span></div>
          <div class="uzone" id="skyZone">
            <input type="file" id="skyInput" accept="image/*" onchange="handleSky(this.files[0])">
            <div class="uzIcon">◉</div>
            <div class="uzLabel">Click or drag an equirectangular panorama</div>
            <div class="uzSub">.jpg 4096×2048 · 2:1 ratio</div>
          </div>
          <div class="fileInfo" id="skyInfo" style="display:none">
            <span class="fn" id="skyFn"></span>
            <span class="fs" id="skyFs"></span>
            <button class="fx" onclick="clearSky()">✕</button>
          </div>
          <img id="skyThumb" class="skyThumb">
        </div>

        <!-- Puzzle Cut Preview -->
        <div class="card" id="cutCard" style="display:none">
          <div class="cardHead">Puzzle Cut Preview</div>
          <div class="cutModes">
            <button class="cutMode active" id="cutModeAuto" onclick="setCutMode('auto')">Auto</button>
            <button class="cutMode" id="cutModeManual" onclick="setCutMode('manual')">Manual Cuts</button>
          </div>
          <div id="cutAutoInfo" style="font-size:10px;color:var(--m);margin-bottom:10px">The model will be split into a 3D grid based on piece count.</div>
          <div id="cutManualInfo" style="font-size:10px;color:var(--m);margin-bottom:10px;display:none">
            Add axis-aligned cut planes. The model is sliced where each plane crosses it.
            <div style="margin-top:8px;display:flex;gap:6px;flex-wrap:wrap">
              <button class="cutPlaneAdd" onclick="addCutPlane('x')" style="padding:5px 12px;background:var(--bg);border:1px solid var(--b);border-radius:3px;font-family:'Jost',sans-serif;font-size:10px;cursor:pointer;color:var(--m);transition:all .15s">+ X plane</button>
              <button class="cutPlaneAdd" onclick="addCutPlane('y')" style="padding:5px 12px;background:var(--bg);border:1px solid var(--b);border-radius:3px;font-family:'Jost',sans-serif;font-size:10px;cursor:pointer;color:var(--m);transition:all .15s">+ Y plane</button>
              <button class="cutPlaneAdd" onclick="addCutPlane('z')" style="padding:5px 12px;background:var(--bg);border:1px solid var(--b);border-radius:3px;font-family:'Jost',sans-serif;font-size:10px;cursor:pointer;color:var(--m);transition:all .15s">+ Z plane</button>
            </div>
            <div class="cutPlaneList" id="cutPlaneList"></div>
          </div>
          <div class="cutPreview" id="cutPreviewContainer">
            <canvas id="cutCanvas"></canvas>
          </div>
          <div style="display:flex;gap:8px;margin-top:10px">
            <button onclick="refreshCutPreview()" style="flex:1;padding:8px;background:var(--bg);border:1px solid var(--b);border-radius:3px;font-family:'Jost',sans-serif;font-size:11px;cursor:pointer;color:var(--m);transition:all .15s">Refresh Preview</button>
          </div>
          <div style="font-size:10px;color:var(--m);margin-top:8px" id="cutPieceCount"></div>
        </div>

        <!-- Danger -->
        <div class="card">
          <div class="cardHead">Danger Zone</div>
          <button class="dangerBtn" onclick="deleteLevel()">Delete This Level</button>
        </div>

      </div><!-- /lvEditor -->
    </div><!-- /editor -->
  </div>
</div>

<!-- Progress overlay -->
<div id="progressOverlay">
  <div class="progBox">
    <div class="progLabel" id="progLabel">Publishing…</div>
    <div class="progBar"><div class="progFill" id="progFill"></div></div>
  </div>
</div>

<div id="toast"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
'use strict';
// ══════════════════════════════════════════════════════════════════
// AUTH  — simple password + GitHub token check
// ══════════════════════════════════════════════════════════════════
const ADMIN_PASSWORD = 'admin'; // Change this to your real password

// ── Auto-detect repo from GitHub Pages URL ──────────────────
// e.g. https://owlie69.github.io/3DBuild/admin.html
// → repo = owlie69/3DBuild
function detectRepo(){
  const host = location.hostname; // owlie69.github.io
  const path = location.pathname; // /3DBuild/admin.html
  const parts = path.split('/').filter(Boolean); // ['3DBuild','admin.html']
  const username = host.split('.')[0]; // owlie69 (read from URL — works automatically)
  const repoName = parts[0] || '';     // 3DBuild
  return repoName ? username+'/'+repoName : null;
}

// Show detected repo in login form on page load
document.addEventListener('DOMContentLoaded',function(){
  const repo = detectRepo();
  const el = document.getElementById('repoDisplay');
  if(el) el.textContent = repo || 'Could not detect — are you on GitHub Pages?';
  if(el && repo) el.style.color='var(--t)';
});

async function login(){
  const pw  = document.getElementById('inPw').value;
  const tok = document.getElementById('inToken').value.trim().replace(/\s+/g,'');
  const err = document.getElementById('loginErr');
  const btn = document.querySelector('.loginBtn');

  const repo = detectRepo();

  if(pw !== ADMIN_PASSWORD){
    err.textContent='Wrong admin password.';err.style.display='block'; return;
  }
  if(!tok){
    err.textContent='Please enter your GitHub token.';err.style.display='block'; return;
  }
  if(!repo){
    err.textContent='Could not detect repo from URL. Are you on GitHub Pages?';err.style.display='block'; return;
  }

  btn.textContent='Checking…';btn.disabled=true;err.style.display='none';

  // Test the token against GitHub API
  try{
    const r=await fetch('https://api.github.com/repos/'+repo,{
      headers:{'Authorization':'Bearer '+tok,'Accept':'application/vnd.github+json','X-GitHub-Api-Version':'2022-11-28'}
    });
    if(r.status===401){err.textContent='Token rejected — make sure it has "repo" scope.';err.style.display='block';btn.textContent='Sign in';btn.disabled=false;return;}
    if(r.status===404){err.textContent='Repo "'+repo+'" not found or token has no access.';err.style.display='block';btn.textContent='Sign in';btn.disabled=false;return;}
    if(!r.ok){err.textContent='GitHub error '+r.status+'. Try again.';err.style.display='block';btn.textContent='Sign in';btn.disabled=false;return;}
  }catch(e){
    err.textContent='Network error: '+e.message;err.style.display='block';btn.textContent='Sign in';btn.disabled=false;return;
  }

  // Store credentials — cleared when tab closes
  sessionStorage.setItem('gh_token', tok);
  sessionStorage.setItem('gh_repo', repo);

  btn.textContent='Sign in';btn.disabled=false;
  document.getElementById('loginScreen').style.display='none';
  document.getElementById('app').style.display='block';
  initApp();
}

function gh(){ return { token: sessionStorage.getItem('gh_token'), repo: sessionStorage.getItem('gh_repo') }; }

// ══════════════════════════════════════════════════════════════════
// GITHUB API helpers
// Uses Bearer auth (works from any origin incl. GitHub Pages)
// ══════════════════════════════════════════════════════════════════
function ghHeaders(){
  const {token}=gh();
  return {
    'Authorization': 'Bearer '+token,
    'Accept': 'application/vnd.github+json',
    'X-GitHub-Api-Version': '2022-11-28'
  };
}
async function ghGet(path){
  const {repo}=gh();
  const r=await fetch(`https://api.github.com/repos/${repo}/contents/${path}`,
    {headers:ghHeaders()});
  if(r.status===404) throw new Error('GET '+path+' → 404');
  if(!r.ok){const e=await r.json().catch(()=>({}));throw new Error(e.message||'GET failed '+r.status);}
  return r.json();
}
// ghPut — uses Git Data API (blobs+trees+commits) — no 1MB limit
async function ghPut(path, content, message){
  const {repo}=gh();
  const H={...ghHeaders(),'Content-Type':'application/json'};
  const api=`https://api.github.com/repos/${repo}`;

  // 1. Get current HEAD commit SHA + tree SHA
  const refR=await fetch(`${api}/git/ref/heads/main`,{headers:H});
  if(!refR.ok) throw new Error('Could not get branch ref: '+refR.status);
  const ref=await refR.json();
  const headSha=ref.object.sha;

  const commitR=await fetch(`${api}/git/commits/${headSha}`,{headers:H});
  if(!commitR.ok) throw new Error('Could not get commit: '+commitR.status);
  const baseTreeSha=(await commitR.json()).tree.sha;

  // 2. Create a blob — send as utf-8 (avoids double-base64 corruption)
  const blobR=await fetch(`${api}/git/blobs`,{
    method:'POST',headers:H,
    body:JSON.stringify({content:content,encoding:'utf-8'})
  });
  if(!blobR.ok) throw new Error('Could not create blob: '+blobR.status);
  const blobSha=(await blobR.json()).sha;

  // 3. Create a new tree pointing to the new blob
  const treeR=await fetch(`${api}/git/trees`,{
    method:'POST',headers:H,
    body:JSON.stringify({base_tree:baseTreeSha,tree:[{path,mode:'100644',type:'blob',sha:blobSha}]})
  });
  if(!treeR.ok) throw new Error('Could not create tree: '+treeR.status);
  const newTreeSha=(await treeR.json()).sha;

  // 4. Create a commit
  const newCommitR=await fetch(`${api}/git/commits`,{
    method:'POST',headers:H,
    body:JSON.stringify({message,tree:newTreeSha,parents:[headSha]})
  });
  if(!newCommitR.ok) throw new Error('Could not create commit: '+newCommitR.status);
  const newCommitSha=(await newCommitR.json()).sha;

  // 5. Update the branch reference
  const updateR=await fetch(`${api}/git/refs/heads/main`,{
    method:'PATCH',headers:H,
    body:JSON.stringify({sha:newCommitSha})
  });
  if(!updateR.ok) throw new Error('Could not update ref: '+updateR.status);
  return updateR.json();
}

// ══════════════════════════════════════════════════════════════════
// STATE
// ══════════════════════════════════════════════════════════════════
let levels=[];   // [{name,pieces,modelFile,modelData(b64),skyFile,skyData(b64),skyMime,calibRX,calibRY,calibRZ}]
let selIdx=-1;
let dirty=false;

function markDirty(){ dirty=true; document.getElementById('statusMsg').textContent='Unsaved changes'; document.getElementById('publishBtn').disabled=false; }
function clearDirty(){ dirty=false; document.getElementById('statusMsg').textContent=''; }

// ══════════════════════════════════════════════════════════════════
// INIT — load existing levels.json from repo
// ══════════════════════════════════════════════════════════════════
async function initApp(){
  toast('Loading existing levels…');
  try{
    const file=await ghGet('levels.json');
    const text=decodeURIComponent(escape(atob(file.content.replace(/\n/g,''))));
    const data=JSON.parse(text);
    levels=data.map(r=>({
      id:r.id||crypto.randomUUID(),
      name:r.name||'Unnamed',
      pieces:r.pieces||15,
      snapTolerance:r.snap_tolerance||30,
      modelData:r.model_data||null,  // base64 stored
      modelFn:r.model_fn||null,
      skyData:r.sky_data||null,
      skyMime:r.sky_mime||'image/jpeg',
      skyFn:r.sky_fn||null,
      calibRX:r.calib_rx||0,
      calibRY:r.calib_ry||0,
      calibRZ:r.calib_rz||0,
      offsetY:r.offset_y||0,
      cutMode:r.cut_mode||'auto',
      cutPlanes:r.cut_planes||[],
      modelFile:null, skyFile:null   // new local files not yet committed
    }));
    toast('Loaded '+levels.length+' level(s)');
  }catch(e){
    if(e.message.includes('404')||e.message.includes('GET levels')){
      toast('No levels yet — create your first one!');
    } else {
      toast('Could not load: '+e.message);
    }
  }
  renderList();
  if(levels.length) selectLevel(0);
}

// ══════════════════════════════════════════════════════════════════
// LEVEL LIST UI
// ══════════════════════════════════════════════════════════════════
let dragSrc=-1;
function renderList(){
  const el=document.getElementById('lvList');
  if(!levels.length){el.innerHTML='<div style="font-size:11px;color:var(--m);padding:10px">No levels yet</div>';return;}
  el.innerHTML=levels.map((l,i)=>`
    <div class="lvItem${i===selIdx?' active':''}" onclick="selectLevel(${i})"
      draggable="true"
      ondragstart="dragSrc=${i};this.style.opacity='.4'"
      ondragend="this.style.opacity='1'"
      ondragover="event.preventDefault();document.querySelectorAll('.lvItem').forEach(e=>e.classList.remove('drag-over'));this.classList.add('drag-over')"
      ondragleave="this.classList.remove('drag-over')"
      ondrop="event.preventDefault();this.classList.remove('drag-over');moveLevel(dragSrc,${i})">
      <span class="drag-handle">⠿</span>
      <div class="lvNum">${i+1}</div>
      <div style="flex:1;min-width:0">
        <div class="lvTitle">${l.name}</div>
        <div class="lvMeta">${l.pieces} pcs · snap ${l.snapTolerance||30}%${l.modelData||l.modelFile?' · ⬡':''} ${l.skyData||l.skyFile?' · 360°':''}</div>
      </div>
    </div>`).join('');
}

function selectLevel(i){
  selIdx=i;
  cutFacesCache=null;cutBoundsCache=null;
  renderList();
  const l=levels[i];
  document.getElementById('noSel').style.display='none';
  document.getElementById('lvEditor').style.display='block';
  document.getElementById('eName').value=l.name;
  document.getElementById('ePieces').value=l.pieces;
  document.getElementById('ePiecesVal').textContent=l.pieces;
  document.getElementById('eSnap').value=l.snapTolerance||30;
  document.getElementById('eSnapVal').textContent=(l.snapTolerance||30)+'%';
  // model
  if(l.modelData||l.modelFile){
    document.getElementById('modelInfo').style.display='flex';
    document.getElementById('modelFn').textContent=l.modelFn||'model.glb';
    document.getElementById('modelFs').textContent=l.modelData?fmtB(l.modelData.length*.75):'new file';
    showCalibSection(l);
  } else { clearModelUI(); }
  // sky
  if(l.skyData||l.skyFile){
    document.getElementById('skyInfo').style.display='flex';
    document.getElementById('skyFn').textContent=l.skyFn||'panorama.jpg';
    document.getElementById('skyFs').textContent=l.skyData?fmtB(l.skyData.length*.75):'new file';
    if(l.skyFile){ const t=document.getElementById('skyThumb');t.src=URL.createObjectURL(l.skyFile);t.style.display='block'; }
    else if(l.skyData){
      const t=document.getElementById('skyThumb');
      t.src='data:'+l.skyMime+';base64,'+l.skyData.slice(0,200)+'…';
      // Use blob for proper preview
      const bin=atob(l.skyData);const u8=new Uint8Array(bin.length);for(let j=0;j<bin.length;j++)u8[j]=bin.charCodeAt(j);
      t.src=URL.createObjectURL(new Blob([u8],{type:l.skyMime}));t.style.display='block';
    }
  } else { clearSkyUI(); }
  // calibration values
  document.getElementById('cRX').value=l.calibRX||0;
  document.getElementById('cRY').value=l.calibRY||0;
  document.getElementById('cRZ').value=l.calibRZ||0;
  document.getElementById('cOY').value=l.offsetY||0;
  document.getElementById('cOYv').textContent=(l.offsetY||0).toFixed(2);
  updateCalibLabels();
}

function syncField(field,val){
  if(selIdx<0)return;
  levels[selIdx][field]=val;
  markDirty();
  if(field==='name'||field==='pieces') renderList();
}

function addLevel(){
  levels.push({id:crypto.randomUUID(),name:'New Level',pieces:15,snapTolerance:30,modelData:null,modelFn:null,skyData:null,skyMime:'image/jpeg',skyFn:null,calibRX:0,calibRY:0,calibRZ:0,offsetY:0,cutMode:'auto',cutPlanes:[],modelFile:null,skyFile:null});
  markDirty();renderList();selectLevel(levels.length-1);
}

function deleteLevel(){
  if(selIdx<0)return;
  if(!confirm('Delete "'+levels[selIdx].name+'"?'))return;
  levels.splice(selIdx,1);
  selIdx=Math.max(0,selIdx-1);
  markDirty();renderList();
  if(levels.length) selectLevel(selIdx);
  else{ document.getElementById('noSel').style.display='flex';document.getElementById('lvEditor').style.display='none'; }
}

function moveLevel(from,to){
  if(from===to||from<0||to<0)return;
  const [m]=levels.splice(from,1);levels.splice(to,0,m);
  selIdx=to;markDirty();renderList();selectLevel(to);
}

// ══════════════════════════════════════════════════════════════════
// MODEL UPLOAD + CALIBRATION
// ══════════════════════════════════════════════════════════════════
function handleModel(file){
  if(!file||selIdx<0)return;
  const idx=selIdx; // capture index at upload time
  levels[idx].modelFile=file;
  levels[idx].modelFn=file.name;
  levels[idx].modelData=null;
  levels[idx]._buf=null; // clear old buffer
  document.getElementById('modelInfo').style.display='flex';
  document.getElementById('modelFn').textContent=file.name;
  document.getElementById('modelFs').textContent=fmtB(file.size);
  const reader=new FileReader();
  reader.onload=e=>{
    levels[idx]._buf=e.target.result; // store raw ArrayBuffer on the level
    showCalibSection(levels[idx], true); // showCalibSection calls initPreview
  };
  reader.readAsArrayBuffer(file);
  markDirty();
}
function clearModel(){
  if(selIdx<0)return;
  levels[selIdx].modelFile=null;levels[selIdx].modelData=null;levels[selIdx].modelFn=null;
  clearModelUI();markDirty();
}
function clearModelUI(){
  document.getElementById('modelInfo').style.display='none';
  document.getElementById('calibSection').style.display='none';
  document.getElementById('cutCard').style.display='none';
  cutFacesCache=null;cutBoundsCache=null;
}

function showCalibSection(l, resetSliders){
  document.getElementById('calibSection').style.display='block';
  if(resetSliders){ l.calibRX=0;l.calibRY=0;l.calibRZ=0;l.offsetY=0; }
  document.getElementById('cRX').value=l.calibRX||0;
  document.getElementById('cRY').value=l.calibRY||0;
  document.getElementById('cRZ').value=l.calibRZ||0;
  document.getElementById('cOY').value=l.offsetY||0;
  document.getElementById('cOYv').textContent=(l.offsetY||0).toFixed(2);
  updateCalibLabels();
  if(l._buf){
    // Already have raw ArrayBuffer from this session upload — use directly
    initPreview(l._buf);
  } else if(l.modelData){
    // Loaded from existing levels.json — decode base64 to buffer
    const b64=l.modelData.replace(/\s/g,'');
    const bin=atob(b64);
    const buf=new ArrayBuffer(bin.length);
    const u8=new Uint8Array(buf);
    for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
    l._buf=buf; // cache it so switching back is instant
    initPreview(buf);
  } else {
    // No model — clear preview
    if(previewModel&&prevScene){prevScene.remove(previewModel);previewModel=null;}
    document.getElementById('calibSection').style.display='none';
  }
}

function updateCalib(){
  updateCalibLabels();
  if(selIdx<0)return;
  levels[selIdx].calibRX=+document.getElementById('cRX').value;
  levels[selIdx].calibRY=+document.getElementById('cRY').value;
  levels[selIdx].calibRZ=+document.getElementById('cRZ').value;
  if(previewModel) applyCalib();
  markDirty();
}
function updateOffsetY(){
  const v=+document.getElementById('cOY').value;
  document.getElementById('cOYv').textContent=v.toFixed(2);
  if(selIdx<0)return;
  levels[selIdx].offsetY=v;
  if(previewModel) previewModel.position.y=v;
  markDirty();
}
function updateCalibLabels(){
  ['RX','RY','RZ'].forEach(a=>{document.getElementById('c'+a+'v').textContent=document.getElementById('c'+a).value+'°';});
}
function resetCalib(){
  ['cRX','cRY','cRZ'].forEach(id=>{document.getElementById(id).value=0;});
  document.getElementById('cOY').value=0;
  document.getElementById('cOYv').textContent='0';
  if(selIdx>=0) levels[selIdx].offsetY=0;
  if(previewModel) previewModel.position.y=0;
  updateCalib();
}

// ── Inline preview renderer ────────────────────────────────────
let prevRenderer=null, prevScene=null, prevCamera=null, previewModel=null;
let prevOrb={r:4,th:.5,ph:.9,on:false,lx:0,ly:0,tx:0,ty:0,tz:0};
let prevLoopRunning=false;

function initPreview(arrayBuffer){
  const container=document.getElementById('previewContainer');
  const canvas=document.getElementById('previewCanvas');

  function loadModel(){
    // Dispose previous model properly
    if(previewModel){
      previewModel.traverse(c=>{
        if(c.isMesh){c.geometry.dispose();if(c.material)c.material.dispose();}
      });
      prevScene.remove(previewModel);
      previewModel=null;
    }
    try{
      const prims=loadGLBSimple(arrayBuffer);
      const group=primsToPreviewMesh(prims);
      prevScene.add(group);
      previewModel=group;
      applyCalib();
      // Fit camera — compute box AFTER adding to scene
      const box=new THREE.Box3().setFromObject(group);
      const sz=box.getSize(new THREE.Vector3()).length()||2;
      const ctr=box.getCenter(new THREE.Vector3());
      const oy=selIdx>=0?(levels[selIdx].offsetY||0):0;
      group.position.y=oy;
      prevOrb.tx=ctr.x; prevOrb.ty=ctr.y+oy; prevOrb.tz=ctr.z;
      prevOrb.r=sz*2.0; prevOrb.ph=.8; prevOrb.th=.5;
      updatePrevOrb();
    }catch(err){console.error('preview parse error',err);}
  }

  function setupRenderer(){
    const w=container.offsetWidth;
    const h=260;
    if(!w){setTimeout(setupRenderer,150);return;} // wait for real layout
    if(!prevRenderer){
      // First time — create renderer, scene, camera, lights, events
      prevRenderer=new THREE.WebGLRenderer({canvas,antialias:true});
      prevRenderer.setClearColor(0x15120e,1);
      prevRenderer.setPixelRatio(window.devicePixelRatio);
      prevRenderer.setSize(w,h);  // true = also set CSS
      prevScene=new THREE.Scene();
      prevCamera=new THREE.PerspectiveCamera(50,w/h,0.05,500);
      prevScene.add(new THREE.AmbientLight(0xffffff,0.9));
      const sun=new THREE.DirectionalLight(0xffffff,1.2);
      sun.position.set(5,10,7);prevScene.add(sun);
      const fill=new THREE.DirectionalLight(0x8090ff,0.3);
      fill.position.set(-5,2,-5);prevScene.add(fill);
      prevScene.add(new THREE.GridHelper(20,20,0x3a3428,0x252018));
      // Resize
      new ResizeObserver(()=>{
        const nw=container.offsetWidth;
        if(!nw||!prevRenderer)return;
        prevRenderer.setSize(nw,h);
        prevCamera.aspect=nw/h;prevCamera.updateProjectionMatrix();
      }).observe(container);
      // Orbit controls
      canvas.addEventListener('mousedown',e=>{prevOrb.on=true;prevOrb.lx=e.clientX;prevOrb.ly=e.clientY;e.preventDefault();},false);
      canvas.addEventListener('touchstart',e=>{const t=e.touches[0];prevOrb.on=true;prevOrb.lx=t.clientX;prevOrb.ly=t.clientY;},{passive:true});
      window.addEventListener('mousemove',e=>{if(!prevOrb.on)return;prevOrb.th-=(e.clientX-prevOrb.lx)*.006;prevOrb.ph=Math.max(.05,Math.min(1.55,prevOrb.ph-(e.clientY-prevOrb.ly)*.006));prevOrb.lx=e.clientX;prevOrb.ly=e.clientY;updatePrevOrb();});
      window.addEventListener('touchmove',e=>{if(!prevOrb.on)return;const t=e.touches[0];prevOrb.th-=(t.clientX-prevOrb.lx)*.006;prevOrb.ph=Math.max(.05,Math.min(1.55,prevOrb.ph-(t.clientY-prevOrb.ly)*.006));prevOrb.lx=t.clientX;prevOrb.ly=t.clientY;updatePrevOrb();},{passive:true});
      window.addEventListener('mouseup',()=>prevOrb.on=false);
      window.addEventListener('touchend',()=>prevOrb.on=false);
      canvas.addEventListener('wheel',e=>{prevOrb.r=Math.max(.5,Math.min(40,prevOrb.r*(1+e.deltaY*.001)));updatePrevOrb();e.preventDefault();},{passive:false});
      if(!prevLoopRunning){
        prevLoopRunning=true;
        (function loop(){requestAnimationFrame(loop);if(prevRenderer&&prevScene&&prevCamera)prevRenderer.render(prevScene,prevCamera);})();
      }
    } else {
      prevRenderer.setSize(w,h);
      prevCamera.aspect=w/h;prevCamera.updateProjectionMatrix();
    }
    loadModel();
  }

  // Give the DOM time to apply display:block and measure the container
  setTimeout(setupRenderer, 120);
}

function applyCalib(){
  if(!previewModel||selIdx<0)return;
  const l=levels[selIdx];
  previewModel.rotation.set(
    (l.calibRX||0)*Math.PI/180,
    (l.calibRY||0)*Math.PI/180,
    (l.calibRZ||0)*Math.PI/180
  );
}
function updatePrevOrb(){
  if(!prevCamera)return;
  prevCamera.position.set(
    prevOrb.tx+prevOrb.r*Math.sin(prevOrb.ph)*Math.sin(prevOrb.th),
    prevOrb.ty+prevOrb.r*Math.cos(prevOrb.ph),
    prevOrb.tz+prevOrb.r*Math.sin(prevOrb.ph)*Math.cos(prevOrb.th)
  );prevCamera.lookAt(prevOrb.tx,prevOrb.ty,prevOrb.tz);
}

// ── Full GLB loader with node-tree walk — same as game, gives correct transforms + textures ──
function loadGLBSimple(buf){
  const v=new DataView(buf);
  if(v.getUint32(0,true)!==0x46546C67) throw new Error('Not GLB');
  let off=12,jc=null,bc=null;
  while(off<buf.byteLength){
    const cl=v.getUint32(off,true),ct=v.getUint32(off+4,true);off+=8;
    if(ct===0x4E4F534A)jc=new TextDecoder().decode(new Uint8Array(buf,off,cl));
    else if(ct===0x004E4942)bc=buf.slice(off,off+cl);
    off+=cl;
  }
  const g=JSON.parse(jc);
  const res=[],imgBytes=[];
  // Store raw image bytes — avoids blob URL fetch issues in primsToPreviewMesh
  if(g.images)for(const im of g.images){
    if(im.bufferView!=null){
      const bv=g.bufferViews[im.bufferView];
      const src=new Uint8Array(bc,bv.byteOffset||0,bv.byteLength);
      const copy=new Uint8Array(src.length);copy.set(src); // copy out of shared buffer
      imgBytes.push({bytes:copy,mime:im.mimeType||'image/jpeg'});
    } else imgBytes.push(null);
  }
  function getAcc(i){
    const a=g.accessors[i],bv=g.bufferViews[a.bufferView];
    const o=(bv.byteOffset||0)+(a.byteOffset||0);
    const n={SCALAR:1,VEC2:2,VEC3:3,VEC4:4}[a.type]||1;
    const T={5121:Uint8Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array}[a.componentType]||Float32Array;
    return new T(bc,o,a.count*n);
  }
  function texUrl(mi){
    if(mi==null||!g.materials)return null;
    const t=g.materials[mi]?.pbrMetallicRoughness?.baseColorTexture?.index;
    return t!=null?(imgBytes[g.textures[t]?.source]||null):null; // returns {bytes,mime} or null
  }
  // Matrix math for node tree walk
  const I=()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
  const mul=(a,b)=>{const r=new Array(16);for(let i=0;i<4;i++)for(let j=0;j<4;j++){let s=0;for(let k=0;k<4;k++)s+=a[i+k*4]*b[k+j*4];r[i+j*4]=s;}return r;};
  const trs=n=>{if(n.matrix)return[...n.matrix];const m=I();if(n.translation){m[12]=n.translation[0];m[13]=n.translation[1];m[14]=n.translation[2];}if(n.rotation){const[qx,qy,qz,qw]=n.rotation;m[0]=1-2*(qy*qy+qz*qz);m[1]=2*(qx*qy+qz*qw);m[2]=2*(qx*qz-qy*qw);m[4]=2*(qx*qy-qz*qw);m[5]=1-2*(qx*qx+qz*qz);m[6]=2*(qy*qz+qx*qw);m[8]=2*(qx*qz+qy*qw);m[9]=2*(qy*qz-qx*qw);m[10]=1-2*(qx*qx+qy*qy);}if(n.scale){m[0]*=n.scale[0];m[1]*=n.scale[0];m[2]*=n.scale[0];m[4]*=n.scale[1];m[5]*=n.scale[1];m[6]*=n.scale[1];m[8]*=n.scale[2];m[9]*=n.scale[2];m[10]*=n.scale[2];}return m;};
  const tp=(m,v)=>{const w=m[3]*v[0]+m[7]*v[1]+m[11]*v[2]+m[15]||1;return[(m[0]*v[0]+m[4]*v[1]+m[8]*v[2]+m[12])/w,(m[1]*v[0]+m[5]*v[1]+m[9]*v[2]+m[13])/w,(m[2]*v[0]+m[6]*v[1]+m[10]*v[2]+m[14])/w];};
  const tn=(m,v)=>{const x=m[0]*v[0]+m[4]*v[1]+m[8]*v[2],y=m[1]*v[0]+m[5]*v[1]+m[9]*v[2],z=m[2]*v[0]+m[6]*v[1]+m[10]*v[2];const l=Math.sqrt(x*x+y*y+z*z)||1;return[x/l,y/l,z/l];};
  function visit(ni,pm){
    const n=g.nodes[ni],wm=mul(pm,trs(n));
    if(n.mesh!=null){
      for(const p of g.meshes[n.mesh].primitives){
        const rp=getAcc(p.attributes.POSITION),rn=p.attributes.NORMAL!=null?getAcc(p.attributes.NORMAL):null;
        const uv=p.attributes.TEXCOORD_0!=null?getAcc(p.attributes.TEXCOORD_0):null,ix=p.indices!=null?getAcc(p.indices):null;
        // COLOR_0: per-vertex colour (RealityCapture / photogrammetry exports)
        const rc0=p.attributes.COLOR_0!=null?getAcc(p.attributes.COLOR_0):null;
        const vc=rp.length/3,pos=new Float32Array(rp.length),nor=rn?new Float32Array(rn.length):null;
        for(let i=0;i<vc;i++){
          const pp=tp(wm,[rp[i*3],rp[i*3+1],rp[i*3+2]]);pos[i*3]=pp[0];pos[i*3+1]=pp[1];pos[i*3+2]=pp[2];
          if(rn){const nn=tn(wm,[rn[i*3],rn[i*3+1],rn[i*3+2]]);nor[i*3]=nn[0];nor[i*3+1]=nn[1];nor[i*3+2]=nn[2];}
        }
        // Determine colour type: VEC4 uint8 (0-255) or VEC4/VEC3 float (0-1)
        let col=null;
        if(rc0){
          const acc=g.accessors[p.attributes.COLOR_0];
          const isUint8=(acc.componentType===5121);
          const isVec4=(acc.type==='VEC4');
          col={data:rc0,isUint8,isVec4};
        }
        res.push({pos,nor,uv,col,idx:ix,texUrl:texUrl(p.material)});
      }
    }
    if(n.children)n.children.forEach(ci=>visit(ci,wm));
  }
  const si=g.scene??0;
  const roots=g.scenes?.[si]?.nodes??g.nodes?.map((_,i)=>i)??[];
  roots.forEach(i=>visit(i,I()));
  // Fallback: if node walk found nothing, iterate meshes directly
  if(!res.length&&g.meshes)for(const m of g.meshes)for(const p of m.primitives){
    const rc0=p.attributes.COLOR_0!=null?getAcc(p.attributes.COLOR_0):null;
    let col=null;
    if(rc0){const acc=g.accessors[p.attributes.COLOR_0];col={data:rc0,isUint8:(acc.componentType===5121),isVec4:(acc.type==='VEC4')};}
    res.push({pos:getAcc(p.attributes.POSITION),nor:p.attributes.NORMAL!=null?getAcc(p.attributes.NORMAL):null,uv:p.attributes.TEXCOORD_0!=null?getAcc(p.attributes.TEXCOORD_0):null,col,idx:p.indices!=null?getAcc(p.indices):null,texUrl:texUrl(p.material)});
  }
  return res;
}
function primsToPreviewMesh(prims){
  const grp=new THREE.Group();
  // Global centre + scale so model fits in ~2.5 unit box
  let mnx=Infinity,mny=Infinity,mnz=Infinity,mxx=-Infinity,mxy=-Infinity,mxz=-Infinity;
  prims.forEach(({pos})=>{for(let i=0;i<pos.length;i+=3){mnx=Math.min(mnx,pos[i]);mxx=Math.max(mxx,pos[i]);mny=Math.min(mny,pos[i+1]);mxy=Math.max(mxy,pos[i+1]);mnz=Math.min(mnz,pos[i+2]);mxz=Math.max(mxz,pos[i+2]);}});
  const cx=(mnx+mxx)/2,cy=(mny+mxy)/2,cz=(mnz+mxz)/2;
  const sc=2.5/Math.max(mxx-mnx,mxy-mny,mxz-mnz,0.001);

  prims.forEach(({pos,nor,uv,col,idx,texUrl})=>{
    // Build flat arrays — expand indexed geometry
    const nTri = idx ? idx.length/3 : pos.length/9;
    const verts = idx ? idx.length : pos.length/3;
    const gv=new Float32Array(verts*3);
    const gn=nor ? new Float32Array(verts*3) : null;
    const gu=uv  ? new Float32Array(verts*2) : null;
    const gc=col ? new Float32Array(verts*3) : null;

    const stride_col = col ? (col.isVec4?4:3) : 0;

    for(let vi=0;vi<verts;vi++){
      const si = idx ? idx[vi] : vi;  // source index
      // position — centred + scaled
      gv[vi*3]   = (pos[si*3]  -cx)*sc;
      gv[vi*3+1] = (pos[si*3+1]-cy)*sc;
      gv[vi*3+2] = (pos[si*3+2]-cz)*sc;
      // normal
      if(gn){ gn[vi*3]=nor[si*3]; gn[vi*3+1]=nor[si*3+1]; gn[vi*3+2]=nor[si*3+2]; }
      // uv
      if(gu){ gu[vi*2]=uv[si*2]; gu[vi*2+1]=uv[si*2+1]; }
      // colour — uint8 normalized or float
      if(gc){
        if(col.isUint8){
          gc[vi*3]   = col.data[si*stride_col]  /255;
          gc[vi*3+1] = col.data[si*stride_col+1]/255;
          gc[vi*3+2] = col.data[si*stride_col+2]/255;
        } else {
          gc[vi*3]   = col.data[si*stride_col];
          gc[vi*3+1] = col.data[si*stride_col+1];
          gc[vi*3+2] = col.data[si*stride_col+2];
        }
      }
    }

    const geo=new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(gv,3));
    if(gn) geo.setAttribute('normal', new THREE.Float32BufferAttribute(gn,3));
    else   geo.computeVertexNormals();
    if(gu && gu.length===verts*2) geo.setAttribute('uv', new THREE.Float32BufferAttribute(gu,2));
    if(gc) geo.setAttribute('color', new THREE.Float32BufferAttribute(gc,3));

    const hasUV  = gu && gu.length===verts*2;
    const hasCol = !!gc;

    const mat=new THREE.MeshStandardMaterial({
      roughness: 0.8, metalness: 0.0,
      side: THREE.DoubleSide,
      vertexColors: hasCol,
      color: (hasCol || (texUrl && hasUV)) ? 0xffffff : 0xc8b49a
    });

    if(texUrl && hasUV && !hasCol){
      const blob=new Blob([texUrl.bytes],{type:texUrl.mime});
      createImageBitmap(blob).then(bmp=>{
        const cvs=document.createElement('canvas');
        cvs.width=bmp.width; cvs.height=bmp.height;
        const ctx=cvs.getContext('2d');
        ctx.translate(0,bmp.height); ctx.scale(1,-1);
        ctx.drawImage(bmp,0,0);
        const tex=new THREE.CanvasTexture(cvs);
        tex.flipY=false;
        mat.map=tex; mat.needsUpdate=true;
      }).catch(e=>console.warn('Texture decode:',e));
    }
    grp.add(new THREE.Mesh(geo,mat));
  });
  return grp;
}

// ══════════════════════════════════════════════════════════════════
// SKY UPLOAD
// ══════════════════════════════════════════════════════════════════
function handleSky(file){
  if(!file||selIdx<0)return;
  levels[selIdx].skyFile=file;levels[selIdx].skyFn=file.name;levels[selIdx].skyMime=file.type||'image/jpeg';
  document.getElementById('skyInfo').style.display='flex';
  document.getElementById('skyFn').textContent=file.name;
  document.getElementById('skyFs').textContent=fmtB(file.size);
  const t=document.getElementById('skyThumb');
  t.src=URL.createObjectURL(file);t.style.display='block';
  markDirty();
}
function clearSky(){
  if(selIdx<0)return;
  levels[selIdx].skyFile=null;levels[selIdx].skyData=null;levels[selIdx].skyFn=null;
  clearSkyUI();markDirty();
}
function clearSkyUI(){
  document.getElementById('skyInfo').style.display='none';
  const t=document.getElementById('skyThumb');t.src='';t.style.display='none';
}

// Drag-drop on zones
['modelZone','skyZone'].forEach(id=>{
  const el=document.getElementById(id);
  el.addEventListener('dragover',e=>{e.preventDefault();el.classList.add('over');});
  el.addEventListener('dragleave',()=>el.classList.remove('over'));
  el.addEventListener('drop',e=>{e.preventDefault();el.classList.remove('over');const f=e.dataTransfer.files[0];if(!f)return;if(id==='modelZone')handleModel(f);else handleSky(f);});
});

// ══════════════════════════════════════════════════════════════════
// PUBLISH — encode to base64 and commit levels.json via GitHub API
// ══════════════════════════════════════════════════════════════════
async function publish(){
  // Check total size — warn if over 50MB (GitHub Pages limit is 100MB per repo)
  const totalBytes=levels.reduce((s,l)=>{
    const m=l.modelData?l.modelData.length*.75:l.modelFile?l.modelFile.size:0;
    const sk=l.skyData?l.skyData.length*.75:l.skyFile?l.skyFile.size:0;
    return s+m+sk;
  },0);
  if(totalBytes>50*1024*1024){
    if(!confirm('Warning: total data is '+Math.round(totalBytes/1024/1024)+'MB. Large files may be slow to load for players. Continue?')) return;
  }

  showProgress('Reading files…', 5);
  document.getElementById('publishBtn').disabled=true;

  // 1. Encode any new files to base64
  let done=0;
  const total=levels.filter(l=>l.modelFile||l.skyFile).reduce((s,l)=>s+(l.modelFile?1:0)+(l.skyFile?1:0),0)||1;

  for(const lvl of levels){
    if(lvl.modelFile){
      showProgress('Encoding model: '+lvl.name+'…', Math.round(done/total*50));
      lvl.modelData=await fileToBase64(lvl.modelFile);
      lvl.modelFile=null;
      done++;
    }
    if(lvl.skyFile){
      showProgress('Encoding panorama: '+lvl.name+'…', Math.round(done/total*50));
      lvl.skyData=await fileToBase64(lvl.skyFile);
      lvl.skyFile=null;
      done++;
    }
  }

  // 2. Apply calibration rotations by baking them into the model data
  // (The game reads calib_rx/ry/rz and applies them before splitting)
  showProgress('Building levels.json…', 60);

  const jsonData=levels.map((l,i)=>({
    id:l.id,
    name:l.name,
    pieces:l.pieces,
    snap_tolerance:l.snapTolerance||30,
    order:i,
    model_data:l.modelData||null,
    model_fn:l.modelFn||null,
    sky_data:l.skyData||null,
    sky_mime:l.skyMime||'image/jpeg',
    sky_fn:l.skyFn||null,
    calib_rx:l.calibRX||0,
    calib_ry:l.calibRY||0,
    calib_rz:l.calibRZ||0,
    offset_y:l.offsetY||0,
    cut_mode:l.cutMode||'auto',
    cut_planes:l.cutPlanes||[]
  }));

  showProgress('Committing to GitHub…', 75);

  try{
    // Get current SHA if file exists (needed for update)
    let sha=null;
    try{ const f=await ghGet('levels.json');sha=f.sha; }catch(e){}

    const jsonStr=JSON.stringify(jsonData, null, 2);
    await ghPut('levels.json', jsonStr, 'Update levels ('+levels.length+' levels)', sha);

    showProgress('Done!', 100);
    setTimeout(hideProgress, 800);
    clearDirty();
    document.getElementById('publishBtn').disabled=false;
    renderList();
    toast('Published! Your site will update in ~30 seconds.');
  }catch(e){
    hideProgress();
    document.getElementById('publishBtn').disabled=false;
    alert('Publish failed: '+e.message);
  }
}

// ══════════════════════════════════════════════════════════════════
// UTILS
// ══════════════════════════════════════════════════════════════════
function fileToBase64(file){
  return new Promise((res,rej)=>{
    const r=new FileReader();
    r.onload=()=>{
      // result is data URL — strip the prefix
      const b64=r.result.split(',')[1];
      res(b64);
    };
    r.onerror=rej;
    r.readAsDataURL(file);
  });
}
function fmtB(b){return b>1e6?(b/1e6).toFixed(1)+' MB':(b/1024).toFixed(0)+' KB';}
function showProgress(label,pct){
  document.getElementById('progressOverlay').classList.add('show');
  document.getElementById('progLabel').textContent=label;
  document.getElementById('progFill').style.width=pct+'%';
}
function hideProgress(){ document.getElementById('progressOverlay').classList.remove('show'); }
function toast(msg){
  const el=document.getElementById('toast');
  el.textContent=msg;el.classList.add('show');
  clearTimeout(el._t);el._t=setTimeout(()=>el.classList.remove('show'),3000);
}

// ══════════════════════════════════════════════════════════════════
// PUZZLE CUT PREVIEW
// ══════════════════════════════════════════════════════════════════
const CUT_COLORS=[0xe05a5a,0xe07a30,0xd4b800,0x4aaa44,0x3a9abb,0x7060cc,0xcc50aa,0x44bbaa,0xdd8844,0x5588dd,0xaa4466,0x66aa44,0x4466cc,0xcc6644,0x44cc88,0xbb5599,0x55bb77,0xcc8833,0x6655cc,0x33aa99];
let cutRenderer=null,cutScene=null,cutCamera=null,cutLoopRunning=false;
let cutOrb={r:4,th:.5,ph:.9,on:false,lx:0,ly:0,tx:0,ty:0,tz:0};
let cutMode='auto';
let cutPlanes=[]; // [{axis:'x'|'y'|'z', pos:0.5}]  pos is 0..1 normalized
let cutFacesCache=null; // cached face list for current model
let cutBoundsCache=null; // {mnx,mny,mnz,mxx,mxy,mxz}
let cutPieceMeshes=[]; // current preview meshes

// Convert admin prims to face objects (same format as game)
function primsToFaces(prims, sc, cx, cy, cz){
  const faces=[];
  for(const prim of prims){
    const {pos,nor,uv,col,idx}=prim;
    const triCount=idx?idx.length/3:pos.length/9;
    for(let t=0;t<triCount;t++){
      const vi=[idx?idx[t*3]:t*3, idx?idx[t*3+1]:t*3+1, idx?idx[t*3+2]:t*3+2];
      const p=vi.map(i=>[(pos[i*3]-cx)*sc,(pos[i*3+1]-cy)*sc,(pos[i*3+2]-cz)*sc]);
      const n=nor?vi.map(i=>[nor[i*3],nor[i*3+1],nor[i*3+2]]):[];
      faces.push({
        pos:p,nor:n,
        cx:(p[0][0]+p[1][0]+p[2][0])/3,
        cy:(p[0][1]+p[1][1]+p[2][1])/3,
        cz:(p[0][2]+p[1][2]+p[2][2])/3
      });
    }
  }
  return faces;
}

// Spatial grid splitter (same algorithm as game)
function splitFaces(faces,N){
  if(!faces.length) return [];
  let mnx=Infinity,mny=Infinity,mnz=Infinity,mxx=-Infinity,mxy=-Infinity,mxz=-Infinity;
  for(const f of faces){mnx=Math.min(mnx,f.cx);mny=Math.min(mny,f.cy);mnz=Math.min(mnz,f.cz);mxx=Math.max(mxx,f.cx);mxy=Math.max(mxy,f.cy);mxz=Math.max(mxz,f.cz);}
  const rx=mxx-mnx||1,ry=mxy-mny||1,rz=mxz-mnz||1;
  const base=Math.cbrt(rx*ry*rz/N);
  let gx=Math.max(1,Math.round(rx/base)),gy=Math.max(1,Math.round(ry/base)),gz=Math.max(1,Math.round(rz/base));
  while(gx*gy*gz<N){
    const opts=[[gx+1,gy,gz],[gx,gy+1,gz],[gx,gy,gz+1]];
    let best=opts[0],bd=Infinity;
    for(const o of opts){const d=Math.abs(o[0]*o[1]*o[2]-N);if(d<bd){bd=d;best=o;}}
    [gx,gy,gz]=best;
  }
  const cells=new Map();
  for(const f of faces){
    const ix=Math.min(gx-1,Math.floor(((f.cx-mnx)/rx)*gx));
    const iy=Math.min(gy-1,Math.floor(((f.cy-mny)/ry)*gy));
    const iz=Math.min(gz-1,Math.floor(((f.cz-mnz)/rz)*gz));
    const key=ix+iy*gx+iz*gx*gy;
    if(!cells.has(key))cells.set(key,[]);
    cells.get(key).push(f);
  }
  let groups=[...cells.values()].filter(g=>g.length>0);
  groups.sort((a,b)=>b.length-a.length);
  while(groups.length>N){const a=groups.pop(),b=groups.pop();groups.push([...a,...b]);groups.sort((a,b)=>b.length-a.length);}
  return groups.filter(g=>g.length>0);
}

// Manual plane splitter — splits faces by axis-aligned planes
function splitByPlanes(faces, planes, bounds){
  if(!faces.length||!planes.length) return [faces];
  const {mnx,mny,mnz,mxx,mxy,mxz}=bounds;
  // Sort planes so we split progressively
  const sorted=[...planes].sort((a,b)=>a.pos-b.pos);
  let groups=[faces];
  for(const pl of sorted){
    const newGroups=[];
    for(const grp of groups){
      const a=[],b=[];
      for(const f of grp){
        let val;
        if(pl.axis==='x') val=(f.cx-mnx)/(mxx-mnx||1);
        else if(pl.axis==='y') val=(f.cy-mny)/(mxy-mny||1);
        else val=(f.cz-mnz)/(mxz-mnz||1);
        if(val<pl.pos) a.push(f); else b.push(f);
      }
      if(a.length) newGroups.push(a);
      if(b.length) newGroups.push(b);
    }
    groups=newGroups;
  }
  return groups.filter(g=>g.length>0);
}

// Build geometry from face group (for preview — no shrink needed)
function buildCutGeo(fg){
  const gv=[],gn=[];
  for(const f of fg){
    for(let k=0;k<3;k++){
      gv.push(f.pos[k][0],f.pos[k][1],f.pos[k][2]);
      if(f.nor&&f.nor[k]) gn.push(f.nor[k][0],f.nor[k][1],f.nor[k][2]);
    }
  }
  const bg=new THREE.BufferGeometry();
  bg.setAttribute('position',new THREE.Float32BufferAttribute(gv,3));
  if(gn.length===gv.length) bg.setAttribute('normal',new THREE.Float32BufferAttribute(gn,3));
  else bg.computeVertexNormals();
  return bg;
}

function setCutMode(mode){
  cutMode=mode;
  document.getElementById('cutModeAuto').classList.toggle('active',mode==='auto');
  document.getElementById('cutModeManual').classList.toggle('active',mode==='manual');
  document.getElementById('cutAutoInfo').style.display=mode==='auto'?'block':'none';
  document.getElementById('cutManualInfo').style.display=mode==='manual'?'block':'none';
  if(selIdx>=0){
    levels[selIdx].cutMode=mode;
    if(mode==='auto') levels[selIdx].cutPlanes=[];
    markDirty();
  }
  refreshCutPreview();
}

function addCutPlane(axis){
  cutPlanes.push({axis,pos:0.5});
  if(selIdx>=0){levels[selIdx].cutPlanes=[...cutPlanes];markDirty();}
  renderCutPlaneList();
  refreshCutPreview();
}

function removeCutPlane(idx){
  cutPlanes.splice(idx,1);
  if(selIdx>=0){levels[selIdx].cutPlanes=[...cutPlanes];markDirty();}
  renderCutPlaneList();
  refreshCutPreview();
}

function updateCutPlane(idx,val){
  cutPlanes[idx].pos=val;
  if(selIdx>=0){levels[selIdx].cutPlanes=[...cutPlanes];markDirty();}
  refreshCutPreview();
}

function renderCutPlaneList(){
  const el=document.getElementById('cutPlaneList');
  if(!cutPlanes.length){el.innerHTML='<div style="font-size:10px;color:var(--m);padding:4px 0">No cut planes added</div>';return;}
  el.innerHTML=cutPlanes.map((p,i)=>`
    <div class="cutPlaneItem">
      <label>${p.axis.toUpperCase()} cut</label>
      <input type="range" min="5" max="95" value="${Math.round(p.pos*100)}" oninput="updateCutPlane(${i},this.value/100);this.nextElementSibling.textContent=this.value+'%'">
      <span class="cpv">${Math.round(p.pos*100)}%</span>
      <button onclick="removeCutPlane(${i})">✕</button>
    </div>
  `).join('');
}

function initCutPreview(){
  const container=document.getElementById('cutPreviewContainer');
  const canvas=document.getElementById('cutCanvas');
  if(!container||!canvas) return;

  function setup(){
    const w=container.offsetWidth;
    const h=300;
    if(!w){setTimeout(setup,150);return;}
    if(!cutRenderer){
      cutRenderer=new THREE.WebGLRenderer({canvas,antialias:true});
      cutRenderer.setClearColor(0x15120e,1);
      cutRenderer.setPixelRatio(window.devicePixelRatio);
      cutRenderer.setSize(w,h);
      cutScene=new THREE.Scene();
      cutCamera=new THREE.PerspectiveCamera(50,w/h,0.05,500);
      cutScene.add(new THREE.AmbientLight(0xffffff,0.7));
      const sun=new THREE.DirectionalLight(0xffffff,1.0);
      sun.position.set(5,10,7);cutScene.add(sun);
      const fill=new THREE.DirectionalLight(0x8090ff,0.2);
      fill.position.set(-5,2,-5);cutScene.add(fill);
      // Orbit controls
      canvas.addEventListener('mousedown',e=>{cutOrb.on=true;cutOrb.lx=e.clientX;cutOrb.ly=e.clientY;e.preventDefault();});
      canvas.addEventListener('touchstart',e=>{const t=e.touches[0];cutOrb.on=true;cutOrb.lx=t.clientX;cutOrb.ly=t.clientY;},{passive:true});
      window.addEventListener('mousemove',e=>{if(!cutOrb.on)return;cutOrb.th-=(e.clientX-cutOrb.lx)*.006;cutOrb.ph=Math.max(.05,Math.min(1.55,cutOrb.ph-(e.clientY-cutOrb.ly)*.006));cutOrb.lx=e.clientX;cutOrb.ly=e.clientY;updateCutOrb();});
      window.addEventListener('touchmove',e=>{if(!cutOrb.on)return;const t=e.touches[0];cutOrb.th-=(t.clientX-cutOrb.lx)*.006;cutOrb.ph=Math.max(.05,Math.min(1.55,cutOrb.ph-(t.clientY-cutOrb.ly)*.006));cutOrb.lx=t.clientX;cutOrb.ly=t.clientY;updateCutOrb();},{passive:true});
      window.addEventListener('mouseup',()=>cutOrb.on=false);
      window.addEventListener('touchend',()=>cutOrb.on=false);
      canvas.addEventListener('wheel',e=>{cutOrb.r=Math.max(.5,Math.min(40,cutOrb.r*(1+e.deltaY*.001)));updateCutOrb();e.preventDefault();},{passive:false});
      new ResizeObserver(()=>{
        const nw=container.offsetWidth;
        if(!nw||!cutRenderer)return;
        cutRenderer.setSize(nw,h);
        cutCamera.aspect=nw/h;cutCamera.updateProjectionMatrix();
      }).observe(container);
      if(!cutLoopRunning){
        cutLoopRunning=true;
        (function loop(){requestAnimationFrame(loop);if(cutRenderer&&cutScene&&cutCamera)cutRenderer.render(cutScene,cutCamera);})();
      }
    } else {
      cutRenderer.setSize(w,h);
      cutCamera.aspect=w/h;cutCamera.updateProjectionMatrix();
    }
  }
  setTimeout(setup,150);
}
function updateCutOrb(){
  if(!cutCamera)return;
  cutCamera.position.set(
    cutOrb.tx+cutOrb.r*Math.sin(cutOrb.ph)*Math.sin(cutOrb.th),
    cutOrb.ty+cutOrb.r*Math.cos(cutOrb.ph),
    cutOrb.tz+cutOrb.r*Math.sin(cutOrb.ph)*Math.cos(cutOrb.th)
  );cutCamera.lookAt(cutOrb.tx,cutOrb.ty,cutOrb.tz);
}

function refreshCutPreview(){
  if(selIdx<0) return;
  const l=levels[selIdx];
  if(!l._buf&&!l.modelData) return;

  // Parse model to faces if not cached
  if(!cutFacesCache){
    let buf=l._buf;
    if(!buf&&l.modelData){
      const b64=l.modelData.replace(/\s/g,'');
      const bin=atob(b64);buf=new ArrayBuffer(bin.length);
      const u8=new Uint8Array(buf);for(let i=0;i<bin.length;i++)u8[i]=bin.charCodeAt(i);
    }
    if(!buf) return;
    const prims=loadGLBSimple(buf);
    // Compute bounds for normalization
    let mnx=Infinity,mny=Infinity,mnz=Infinity,mxx=-Infinity,mxy=-Infinity,mxz=-Infinity;
    prims.forEach(({pos})=>{for(let i=0;i<pos.length;i+=3){mnx=Math.min(mnx,pos[i]);mxx=Math.max(mxx,pos[i]);mny=Math.min(mny,pos[i+1]);mxy=Math.max(mxy,pos[i+1]);mnz=Math.min(mnz,pos[i+2]);mxz=Math.max(mxz,pos[i+2]);}});
    const cx=(mnx+mxx)/2,cy=(mny+mxy)/2,cz=(mnz+mxz)/2;
    const sc=2.5/Math.max(mxx-mnx,mxy-mny,mxz-mnz,0.001);
    cutFacesCache=primsToFaces(prims,sc,cx,cy,cz);
    // Compute normalized bounds for the cut faces
    let b={mnx:Infinity,mny:Infinity,mnz:Infinity,mxx:-Infinity,mxy:-Infinity,mxz:-Infinity};
    for(const f of cutFacesCache){b.mnx=Math.min(b.mnx,f.cx);b.mny=Math.min(b.mny,f.cy);b.mnz=Math.min(b.mnz,f.cz);b.mxx=Math.max(b.mxx,f.cx);b.mxy=Math.max(b.mxy,f.cy);b.mxz=Math.max(b.mxz,f.cz);}
    cutBoundsCache=b;
  }

  // Initialize renderer if needed
  if(!cutRenderer) initCutPreview();

  // Clear old meshes
  cutPieceMeshes.forEach(m=>{cutScene.remove(m);m.geometry.dispose();m.material.dispose();});
  cutPieceMeshes=[];
  // Also clear plane helpers
  if(cutScene) cutScene.children.filter(c=>c.userData.isCutPlane).forEach(c=>cutScene.remove(c));

  // Split
  let groups;
  if(cutMode==='manual'&&cutPlanes.length){
    groups=splitByPlanes(cutFacesCache,cutPlanes,cutBoundsCache);
  } else {
    groups=splitFaces(cutFacesCache,l.pieces||15);
  }

  // Build meshes with distinct colors and small gaps
  const SHRINK=0.025;
  groups.forEach((grp,i)=>{
    // Shrink each group toward its centroid for visible gaps
    let pcx=0,pcy=0,pcz=0,cnt=0;
    for(const f of grp){for(const v of f.pos){pcx+=v[0];pcy+=v[1];pcz+=v[2];cnt++;}}
    pcx/=cnt;pcy/=cnt;pcz/=cnt;
    const gv=[],gn=[];
    for(const f of grp){
      for(let k=0;k<3;k++){
        const v=f.pos[k];
        gv.push(v[0]+(pcx-v[0])*SHRINK, v[1]+(pcy-v[1])*SHRINK, v[2]+(pcz-v[2])*SHRINK);
        if(f.nor&&f.nor[k]) gn.push(f.nor[k][0],f.nor[k][1],f.nor[k][2]);
      }
    }
    const geo=new THREE.BufferGeometry();
    geo.setAttribute('position',new THREE.Float32BufferAttribute(gv,3));
    if(gn.length===gv.length) geo.setAttribute('normal',new THREE.Float32BufferAttribute(gn,3));
    else geo.computeVertexNormals();
    const mat=new THREE.MeshStandardMaterial({color:CUT_COLORS[i%CUT_COLORS.length],roughness:.7,metalness:0,side:THREE.DoubleSide});
    const mesh=new THREE.Mesh(geo,mat);
    cutScene.add(mesh);
    cutPieceMeshes.push(mesh);
  });

  // Draw manual cut plane indicators
  if(cutMode==='manual'&&cutPlanes.length&&cutBoundsCache){
    const b=cutBoundsCache;
    const sz=Math.max(b.mxx-b.mnx,b.mxy-b.mny,b.mxz-b.mnz,1);
    cutPlanes.forEach(pl=>{
      const planeGeo=new THREE.PlaneGeometry(sz*1.3,sz*1.3);
      const planeMat=new THREE.MeshBasicMaterial({color:0xff4444,transparent:true,opacity:0.12,side:THREE.DoubleSide,depthWrite:false});
      const planeMesh=new THREE.Mesh(planeGeo,planeMat);
      planeMesh.userData.isCutPlane=true;
      if(pl.axis==='x'){
        planeMesh.rotation.y=Math.PI/2;
        planeMesh.position.x=b.mnx+(b.mxx-b.mnx)*pl.pos;
        planeMesh.position.y=(b.mny+b.mxy)/2;
        planeMesh.position.z=(b.mnz+b.mxz)/2;
      } else if(pl.axis==='y'){
        planeMesh.rotation.x=Math.PI/2;
        planeMesh.position.x=(b.mnx+b.mxx)/2;
        planeMesh.position.y=b.mny+(b.mxy-b.mny)*pl.pos;
        planeMesh.position.z=(b.mnz+b.mxz)/2;
      } else {
        planeMesh.position.x=(b.mnx+b.mxx)/2;
        planeMesh.position.y=(b.mny+b.mxy)/2;
        planeMesh.position.z=b.mnz+(b.mxz-b.mnz)*pl.pos;
      }
      cutScene.add(planeMesh);
    });
  }

  // Fit camera
  cutOrb.tx=0;cutOrb.ty=0;cutOrb.tz=0;cutOrb.r=4;cutOrb.ph=.8;cutOrb.th=.5;
  updateCutOrb();

  document.getElementById('cutPieceCount').textContent='Preview: '+groups.length+' piece'+(groups.length===1?'':'s')+' ('+cutFacesCache.length+' triangles)';
  document.getElementById('cutCard').style.display='block';
}

// Show cut card when model is loaded (hook into showCalibSection)
const _origShowCalib=showCalibSection;
showCalibSection=function(l,resetSliders){
  _origShowCalib(l,resetSliders);
  // Reset cut cache when model changes
  cutFacesCache=null;cutBoundsCache=null;
  // Load saved cut settings
  cutMode=l.cutMode||'auto';
  cutPlanes=l.cutPlanes?[...l.cutPlanes]:[];
  document.getElementById('cutModeAuto').classList.toggle('active',cutMode==='auto');
  document.getElementById('cutModeManual').classList.toggle('active',cutMode==='manual');
  document.getElementById('cutAutoInfo').style.display=cutMode==='auto'?'block':'none';
  document.getElementById('cutManualInfo').style.display=cutMode==='manual'?'block':'none';
  renderCutPlaneList();
  // Delayed preview — let calibration preview init first
  setTimeout(()=>refreshCutPreview(),400);
};
</script>
</body>
</html>
